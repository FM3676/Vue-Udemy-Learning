1
00:00:02,060 --> 00:00:05,510
所以我们使用突变来编辑我们的数据

2
00:00:05,510 --> 00:00:06,500
在该州，

3
00:00:06,500 --> 00:00:08,130
在商店里。

4
00:00:08,130 --> 00:00:11,350
现在就像我们不应该直接编辑状态一样，

5
00:00:11,350 --> 00:00:12,800
从内部组件，

6
00:00:12,800 --> 00:00:16,280
我们也可以争辩说，直接读取状态，

7
00:00:16,280 --> 00:00:18,660
可能并不理想。

8
00:00:18,660 --> 00:00:21,133
为什么这可能是次优的？

9
00:00:22,020 --> 00:00:23,196
那么在这个应用程序中，我们得到了，

10
00:00:23,196 --> 00:00:24,650
计数器组件，

11
00:00:24,650 --> 00:00:26,870
我输出到计数器的地方。

12
00:00:26,870 --> 00:00:28,460
现在让我们说无论出于何种原因

13
00:00:28,460 --> 00:00:30,203
我们还有另一个组件。

14
00:00:31,090 --> 00:00:33,910
最喜欢的value.vue

15
00:00:34,980 --> 00:00:38,840
在他们那里，我们做与柜台相同的事情。

16
00:00:38,840 --> 00:00:40,210
但也许我们做得更多。

17
00:00:40,210 --> 00:00:42,430
这就是为什么我们有单独的组件。

18
00:00:42,430 --> 00:00:44,353
所以我们在这里做得更多。

19
00:00:47,040 --> 00:00:48,990
现在我们当然可以使用它

20
00:00:48,990 --> 00:00:49,960
这里的组件，

21
00:00:49,960 --> 00:00:50,793
在 AppVue 中，

22
00:00:50,793 --> 00:00:55,793
我们可以从组件中导入 FavoriteValue

23
00:00:56,150 --> 00:00:57,727
收藏价值.vue

24
00:00:57,727 --> 00:01:00,050
并在这里注册，

25
00:01:00,050 --> 00:01:03,100
也可以在柜台下方添加这个。

26
00:01:03,100 --> 00:01:05,492
喜欢的值是这样的。

27
00:01:07,530 --> 00:01:09,250
现在当然可以了。

28
00:01:09,250 --> 00:01:10,750
我们现在有两次柜台，

29
00:01:10,750 --> 00:01:13,630
并在两个组件中更新。

30
00:01:13,630 --> 00:01:15,350
现在让我们说我们决定

31
00:01:15,350 --> 00:01:18,270
实际上我们总是希望我们的输出能够反击

32
00:01:18,270 --> 00:01:19,520
两次。

33
00:01:19,520 --> 00:01:22,340
所以我们在FavoriteValue这里更新

34
00:01:22,340 --> 00:01:24,713
我们在柜台更新它。

35
00:01:26,420 --> 00:01:27,940
你看到问题了吗？

36
00:01:27,940 --> 00:01:31,360
我们在这里再次复制逻辑。

37
00:01:31,360 --> 00:01:33,060
我们确实有重复的代码。

38
00:01:33,060 --> 00:01:36,820
再一次在更大更现实的应用中，

39
00:01:36,820 --> 00:01:38,670
这绝对可能发生。

40
00:01:38,670 --> 00:01:42,000
我们在不同的组件中需要相同类型的数据，

41
00:01:42,000 --> 00:01:44,980
然后我们决定要格式化

42
00:01:44,980 --> 00:01:47,400
或以不同的方式计算数据。

43
00:01:47,400 --> 00:01:49,690
因此我们突然需要改变它

44
00:01:49,690 --> 00:01:51,283
在所有不同的地方。

45
00:01:52,490 --> 00:01:57,120
这就是为什么我们可能不想直接与国家对话的原因。

46
00:01:57,120 --> 00:02:00,730
相反，我们可以使用一个名为 Getters 的概念。

47
00:02:00,730 --> 00:02:01,930
到底是哪一个，

48
00:02:01,930 --> 00:02:04,110
你可以说电脑属性

49
00:02:04,110 --> 00:02:07,080
直接在商店中定义，

50
00:02:07,080 --> 00:02:09,710
然后我们可以从任何组件内部使用它

51
00:02:09,710 --> 00:02:11,640
我们的选择。

52
00:02:11,640 --> 00:02:15,830
所以这就是我们如何在我们的 Vuex 存储中添加一个 getter。

53
00:02:15,830 --> 00:02:17,760
除了突变，

54
00:02:17,760 --> 00:02:20,910
并不重要，但在同一个地方

55
00:02:20,910 --> 00:02:22,510
状态和突变，

56
00:02:22,510 --> 00:02:24,176
你添加吸气剂。

57
00:02:24,176 --> 00:02:26,046
这需要一个对象，

58
00:02:26,046 --> 00:02:29,590
现在每个 getter 都是这个对象中的一个方法。

59
00:02:29,590 --> 00:02:32,810
所以基本上就像计算机属性是方法一样

60
00:02:32,810 --> 00:02:35,770
在组件的计算选项中。

61
00:02:35,770 --> 00:02:38,960
在这里我们可以有最后的计数器吸气剂

62
00:02:38,960 --> 00:02:40,450
让我们说。

63
00:02:40,450 --> 00:02:43,210
以及最终的 Counter Getter 方法

64
00:02:43,210 --> 00:02:45,397
像 Vuex 中的所有 getter 方法一样，

65
00:02:45,397 --> 00:02:47,940
得到两个参数。

66
00:02:47,940 --> 00:02:49,490
目前的状态，

67
00:02:49,490 --> 00:02:51,847
我们需要从中获得价值，

68
00:02:51,847 --> 00:02:54,649
和其他吸气剂。

69
00:02:54,649 --> 00:02:57,550
在吸气剂中获取其他吸气剂

70
00:02:57,550 --> 00:03:01,090
如果您想在此处计算的值可能会有所帮助，

71
00:03:01,090 --> 00:03:04,140
取决于另一个吸气剂的结果。

72
00:03:04,140 --> 00:03:05,260
但让我们暂时忽略这一点，

73
00:03:05,260 --> 00:03:08,040
让我们使用 state 参数。

74
00:03:08,040 --> 00:03:10,100
我们想在这里返回一个值，

75
00:03:10,100 --> 00:03:12,098
getter 必须返回一个值。

76
00:03:12,098 --> 00:03:14,470
而这里的值就是我们的计数器

77
00:03:14,470 --> 00:03:16,290
由该州管理，

78
00:03:16,290 --> 00:03:17,823
两次让我们说。

79
00:03:19,310 --> 00:03:21,760
我们现在可以使用这个 getter

80
00:03:21,760 --> 00:03:24,170
从我们选择的任何组件。

81
00:03:24,170 --> 00:03:25,040
例如，

82
00:03:25,040 --> 00:03:28,120
从柜台里面。

83
00:03:28,120 --> 00:03:30,370
在这个计算属性中，

84
00:03:30,370 --> 00:03:31,540
我们保留的，

85
00:03:31,540 --> 00:03:34,320
我们现在访问这个 $store，

86
00:03:34,320 --> 00:03:36,830
但不再是国家，而是

87
00:03:36,830 --> 00:03:38,150
store.getters。

88
00:03:39,580 --> 00:03:41,710
然后是你的吸气剂的名字。

89
00:03:41,710 --> 00:03:44,187
在这种情况下是 FinalCounter。

90
00:03:45,190 --> 00:03:47,730
所以这里也是FinalCounter。

91
00:03:47,730 --> 00:03:49,070
而你不叫它，

92
00:03:49,070 --> 00:03:50,520
你不执行它，

93
00:03:50,520 --> 00:03:52,033
你只是指向它。

94
00:03:53,010 --> 00:03:53,843
像这样。

95
00:03:53,843 --> 00:03:55,007
就像一个财产。

96
00:03:55,007 --> 00:03:59,230
然后 Vuex 会为你执行这个 getter 方法，

97
00:03:59,230 --> 00:04:02,023
将当前状态传递给 getter。

98
00:04:03,430 --> 00:04:04,950
所以我们在这里做这个，

99
00:04:04,950 --> 00:04:06,190
在柜台，

100
00:04:06,190 --> 00:04:08,153
并且在 FavoriteValue 中。

101
00:04:09,330 --> 00:04:12,830
如果我们决定计数器应该是

102
00:04:12,830 --> 00:04:15,360
让我们说价值乘以三，

103
00:04:15,360 --> 00:04:17,730
我们只需要在一个地方做这件事，

104
00:04:17,730 --> 00:04:19,733
而不是在两个地方。

105
00:04:21,410 --> 00:04:23,520
因此，

106
00:04:23,520 --> 00:04:26,150
如果我们回去，

107
00:04:26,150 --> 00:04:28,713
你现在看到这有效。

108
00:04:29,620 --> 00:04:31,613
这就是吸气剂的概念。

109
00:04:33,222 --> 00:04:35,900
现在我提到你不能有多个吸气剂，

110
00:04:35,900 --> 00:04:39,340
并且吸气剂也可以相互依赖。

111
00:04:39,340 --> 00:04:40,173
可以说，

112
00:04:40,173 --> 00:04:42,120
除了我们的 FinalCounter getter，

113
00:04:42,120 --> 00:04:44,540
我们有另一个吸气剂

114
00:04:45,650 --> 00:04:47,543
这称为标准化计数器。

115
00:04:49,558 --> 00:04:51,170
这里的想法很简单，

116
00:04:51,170 --> 00:04:54,030
我想用我的计数器值，

117
00:04:54,030 --> 00:04:56,720
准确地说是 FinalCounter 值，

118
00:04:56,720 --> 00:05:00,370
但我想确保它大于零

119
00:05:00,370 --> 00:05:02,353
并且小于 100。

120
00:05:03,270 --> 00:05:07,150
如果这个边界之一，我要么输出零，要么输出 100

121
00:05:07,150 --> 00:05:08,770
被交叉。

122
00:05:08,770 --> 00:05:10,770
现在构建这个的一种方法，

123
00:05:10,770 --> 00:05:11,940
将会，

124
00:05:11,940 --> 00:05:15,850
我们在这里重新计算我们的计数器乘以三，

125
00:05:15,850 --> 00:05:20,430
然后我们在这里有我们的 FinalCounter。

126
00:05:20,430 --> 00:05:24,010
我们检查 FinalCounter 是否小于零，

127
00:05:24,010 --> 00:05:27,330
这不可能在这里发生，但可以说我们仍然检查它。

128
00:05:27,330 --> 00:05:29,600
在这种情况下，我们返回零，

129
00:05:29,600 --> 00:05:33,120
我们检查 FinalCounter 是否大于 100，

130
00:05:33,120 --> 00:05:35,173
在这种情况下，我们返回 100。

131
00:05:36,270 --> 00:05:39,400
只有当这两种情况都不是时，

132
00:05:39,400 --> 00:05:41,437
我们返回 FinalCounter。

133
00:05:42,680 --> 00:05:43,550
作为旁注，

134
00:05:43,550 --> 00:05:46,160
这也向我们表明，你当然

135
00:05:46,160 --> 00:05:48,990
在 getter 中可以有不止一行代码。

136
00:05:48,990 --> 00:05:51,610
这是使用 getter 的另一个优点。

137
00:05:51,610 --> 00:05:53,350
你可以移动这样的代码

138
00:05:53,350 --> 00:05:56,360
将组件放入您的 Vuex 商店。

139
00:05:56,360 --> 00:05:58,383
让您的组件保持领先。

140
00:05:59,920 --> 00:06:02,680
但是现在我们得到了 normalizedCounter。

141
00:06:02,680 --> 00:06:05,080
我们可以使用 normalizedCounter

142
00:06:05,080 --> 00:06:06,910
在 FavoriteValue 组件中。

143
00:06:06,910 --> 00:06:10,703
只需在此处引用 normalizedCounter 即可。

144
00:06:13,370 --> 00:06:15,440
这就是这个吸气剂的名字。

145
00:06:15,440 --> 00:06:17,570
有了它，你会看到

146
00:06:17,570 --> 00:06:19,790
一旦我们超过100，

147
00:06:19,790 --> 00:06:22,720
底部计数器保持在 100。

148
00:06:22,720 --> 00:06:24,853
因为我们刚刚添加的逻辑。

149
00:06:26,020 --> 00:06:28,423
现在这个工作，但它不是很好。

150
00:06:29,730 --> 00:06:31,930
我们正在计算一些东西，

151
00:06:31,930 --> 00:06:34,810
我们已经在另一个 getter 中计算过了。

152
00:06:34,810 --> 00:06:38,820
这就是为什么我们在这里得到这个吸气剂的第二个参数。

153
00:06:38,820 --> 00:06:41,530
有了它，我们可以参考我们的吸气剂，

154
00:06:41,530 --> 00:06:42,780
并获得我们的 FinalCounter，

155
00:06:43,730 --> 00:06:46,553
只需调用 getters.FinalCounter

156
00:06:47,780 --> 00:06:50,230
想象一下我们有更多的代码。

157
00:06:50,230 --> 00:06:52,740
在另一个吸气剂中复制所有内容，

158
00:06:52,740 --> 00:06:56,413
如果我们已经有一个吸气剂，那就没有必要了。

159
00:06:57,270 --> 00:07:00,490
这就是我们可以在这里使用 finalCounter 的方式。

160
00:07:00,490 --> 00:07:01,330
在这种情况下，

161
00:07:01,330 --> 00:07:03,350
我什至不需要说明它们，

162
00:07:03,350 --> 00:07:06,080
但如果我们需要它，我们仍然可以使用它。

163
00:07:06,080 --> 00:07:07,523
在这第二个吸气剂中。

164
00:07:09,160 --> 00:07:12,540
在这里，我将用一个低于分数的状态参数替换，

165
00:07:12,540 --> 00:07:15,360
这是一个对流信号，我的设置，

166
00:07:15,360 --> 00:07:19,570
我的项目设置在这里我必须接受这个论点

167
00:07:19,570 --> 00:07:21,559
为了到达第二个，

168
00:07:21,559 --> 00:07:24,270
但后来我不想使用它。

169
00:07:24,270 --> 00:07:26,790
否则这个特定的项目设置，

170
00:07:26,790 --> 00:07:29,420
不会抱怨未使用的论点，

171
00:07:29,420 --> 00:07:31,070
遵循这个命名对流。

172
00:07:31,070 --> 00:07:32,163
它不会抱怨。

173
00:07:33,020 --> 00:07:35,110
如果我们得到相同的行为，如果我们重新加载

174
00:07:35,110 --> 00:07:36,500
和以前一样，

175
00:07:36,500 --> 00:07:38,933
但现在以一种更优雅的方式。