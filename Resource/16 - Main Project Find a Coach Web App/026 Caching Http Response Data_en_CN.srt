1
00:00:02,140 --> 00:00:03,910
现在，这是一个很长的模块

2
00:00:03,910 --> 00:00:07,060
这个课程的项目已经完成了，

3
00:00:07,060 --> 00:00:11,320
但我想做或实施最后一个调整。

4
00:00:11,320 --> 00:00:14,450
目前在这个应用程序中，我们并不真正需要 Vue X。

5
00:00:14,450 --> 00:00:16,040
每当我们访问一个页面时，

6
00:00:16,040 --> 00:00:18,573
无论如何，我们都会加载我们需要的所有数据。

7
00:00:19,490 --> 00:00:22,570
尤其是在教练页面上，

8
00:00:22,570 --> 00:00:24,280
对此我不确定。

9
00:00:24,280 --> 00:00:27,660
新教练不太可能签约

10
00:00:27,660 --> 00:00:29,360
一直以来，我们因此

11
00:00:29,360 --> 00:00:31,460
总是需要加载最新的数据，

12
00:00:31,460 --> 00:00:34,010
每当我们回到这个页面。

13
00:00:34,010 --> 00:00:37,070
我们可以在本地缓存数据

14
00:00:37,070 --> 00:00:41,620
并且只在我们说一分钟左右后刷新它，

15
00:00:41,620 --> 00:00:44,630
或者一旦我们手动点击了刷新按钮

16
00:00:45,720 --> 00:00:48,760
这就是我们可以用 Vue X 轻松实现的东西。

17
00:00:48,760 --> 00:00:52,210
再一次，所有这些都向我们展示了为什么我们可能需要

18
00:00:52,210 --> 00:00:54,220
本地管理的状态，

19
00:00:54,220 --> 00:00:55,790
我们用 Vue X 做的

20
00:00:55,790 --> 00:00:59,150
与服务端管理的数据并排。

21
00:00:59,150 --> 00:01:03,070
因为目前我们几乎用 Firebase 替换了 Vue X

22
00:01:03,070 --> 00:01:05,340
这不是想法。

23
00:01:05,340 --> 00:01:07,300
那么我们可以在这里做些什么来不获取

24
00:01:07,300 --> 00:01:09,280
一直有新的教练数据。

25
00:01:09,280 --> 00:01:11,683
而是重用现有数据。

26
00:01:12,600 --> 00:01:15,600
在我们在该州的教练模块中，

27
00:01:15,600 --> 00:01:17,760
除了管理教练，

28
00:01:17,760 --> 00:01:22,760
我们可以添加最后一个获取键，它最初为空。

29
00:01:23,810 --> 00:01:27,100
现在 last fetch 应该包含一个时间戳。

30
00:01:27,100 --> 00:01:29,010
它应该保存一个时间戳。

31
00:01:29,010 --> 00:01:31,763
每当我们获取新数据时。

32
00:01:32,640 --> 00:01:34,993
为此，我们可以添加一个新的突变，

33
00:01:36,010 --> 00:01:41,010
我们将其命名为 set Fetch Timestamp，例如，

34
00:01:41,350 --> 00:01:43,140
在那里我可以访问我的状态。

35
00:01:43,140 --> 00:01:45,310
然后我说，最后一次获取，

36
00:01:45,310 --> 00:01:48,270
这是我们刚刚添加的新数据属性

37
00:01:48,270 --> 00:01:51,500
等于新的 Date.get 时间。

38
00:01:51,500 --> 00:01:55,030
这给了我们当前的时间和日期

39
00:01:55,030 --> 00:01:57,410
作为一个时间戳，作为一个大数字，

40
00:01:57,410 --> 00:02:00,150
基本上是以毫秒为单位的时间

41
00:02:00,150 --> 00:02:01,890
自古以来，

42
00:02:01,890 --> 00:02:05,293
在 JavaScript 中是 1970 年初。

43
00:02:06,270 --> 00:02:08,820
所以现在我们存储这个时间快照

44
00:02:08,820 --> 00:02:11,093
上次获取的此时间戳。

45
00:02:12,000 --> 00:02:16,130
现在我们可以在获取数据时提交这个动作。

46
00:02:16,130 --> 00:02:18,410
所以在我们的行动中，

47
00:02:18,410 --> 00:02:20,130
在负载教练这里，

48
00:02:20,130 --> 00:02:22,240
那是我们获取数据的地方。

49
00:02:22,240 --> 00:02:26,450
最后，我们可以提交多个突变

50
00:02:26,450 --> 00:02:28,630
我们也可以提交

51
00:02:28,630 --> 00:02:32,460
我们的新突变集，获取，时间戳，

52
00:02:32,460 --> 00:02:33,643
我们刚刚添加的。

53
00:02:35,030 --> 00:02:38,170
而且我们不需要在这里提供任何有效载荷

54
00:02:38,170 --> 00:02:41,920
因为 set、fetch、timestamp 不需要任何东西。

55
00:02:41,920 --> 00:02:43,930
所以现在我们存储那个时间戳

56
00:02:43,930 --> 00:02:45,890
当我们丢失获取数据时。

57
00:02:45,890 --> 00:02:47,570
我为什么要这样做？

58
00:02:47,570 --> 00:02:51,140
因为现在我们可以在这个 coaches 模块中添加一个 Getter，

59
00:02:51,140 --> 00:02:54,313
我们可能是名字，应该更新。

60
00:02:56,110 --> 00:03:00,720
最后，我想得到我的最后一个获取时间戳

61
00:03:00,720 --> 00:03:04,023
并找出它是否是，让我们说不到一分钟前。

62
00:03:05,500 --> 00:03:06,800
所以在这里我们得到了我们的状态

63
00:03:08,030 --> 00:03:09,948
然后我们通过访问最后一次获取

64
00:03:09,948 --> 00:03:11,013
state.lastFetch。

65
00:03:12,560 --> 00:03:16,730
我们首先检查最后一次提取是否有问题。

66
00:03:16,730 --> 00:03:18,920
例如，在开始时，它是空的。

67
00:03:18,920 --> 00:03:20,650
如果是这种情况，我会返回 true

68
00:03:20,650 --> 00:03:22,370
因为那时我们应该更新。

69
00:03:22,370 --> 00:03:25,213
如果我们还没有时间戳，我们应该更新。

70
00:03:26,640 --> 00:03:29,040
否则，如果我们确实有时间戳，

71
00:03:29,040 --> 00:03:31,690
我需要知道它是否在一分钟前，

72
00:03:31,690 --> 00:03:34,190
所以我们现在可以得到一个当前的时间戳

73
00:03:35,230 --> 00:03:38,440
通过让你约会得到时间。

74
00:03:38,440 --> 00:03:41,163
这就是我们使用 Getter 时的时间戳。

75
00:03:42,810 --> 00:03:44,760
现在我们可以返回

76
00:03:44,760 --> 00:03:47,230
比较当前时间戳的结果

77
00:03:47,230 --> 00:03:49,390
带有存储时间戳。

78
00:03:49,390 --> 00:03:54,390
我们简单地，从当前时间戳中减去最后一次获取，

79
00:03:56,390 --> 00:04:01,390
除以 1000 并检查是否大于 60。

80
00:04:02,300 --> 00:04:05,040
这意味着它已经超过一分钟了。

81
00:04:05,040 --> 00:04:08,800
如果超过一分钟，这将返回 true。

82
00:04:08,800 --> 00:04:12,290
所以我们应该再次更新，它返回false，

83
00:04:12,290 --> 00:04:13,970
所以我们不应该再次更新，

84
00:04:13,970 --> 00:04:15,613
如果不到一分钟前，

85
00:04:16,870 --> 00:04:18,260
除以 1000，

86
00:04:18,260 --> 00:04:21,012
因为这两个数字都以毫秒为单位。

87
00:04:22,160 --> 00:04:23,750
所以现在它应该更新收益率为真。

88
00:04:23,750 --> 00:04:27,620
如果我们应该再次获取，否则为假。

89
00:04:27,620 --> 00:04:30,973
我们现在应该在哪里更新？

90
00:04:32,310 --> 00:04:35,360
好吧，在教练模块的行动中。

91
00:04:35,360 --> 00:04:39,320
在负载教练中，在我们发送请求之前，

92
00:04:39,320 --> 00:04:42,830
我想看看我们是否真的应该找教练。

93
00:04:42,830 --> 00:04:45,440
所以我们可以检查上下文，

94
00:04:45,440 --> 00:04:46,373
吸气剂，

95
00:04:48,000 --> 00:04:49,420
应该更新

96
00:04:49,420 --> 00:04:51,780
是真的或准确地说，

97
00:04:51,780 --> 00:04:53,343
如果不是真的。

98
00:04:54,200 --> 00:04:57,030
如果不是真的，我会回到这里。

99
00:04:57,030 --> 00:04:59,340
我不会继续其余的代码

100
00:04:59,340 --> 00:05:01,950
因此，我们不会发送请求。

101
00:05:01,950 --> 00:05:03,790
相反，我们将坚持数据

102
00:05:03,790 --> 00:05:06,680
我们目前在我们的商店。

103
00:05:06,680 --> 00:05:08,483
所以我们不会再取了。

104
00:05:09,350 --> 00:05:11,350
如果应该更新是真的。

105
00:05:11,350 --> 00:05:13,350
此 if 语句将被跳过

106
00:05:13,350 --> 00:05:15,283
我们将再次获取数据。

107
00:05:16,910 --> 00:05:19,790
通过这样做，如果我保存它，如果我重新加载，

108
00:05:19,790 --> 00:05:23,300
我们获取数据，但如果我然后去请求并返回，

109
00:05:23,300 --> 00:05:27,500
你看不到加载微调器，因为现在我们不再加载。

110
00:05:27,500 --> 00:05:29,900
一分钟后你会再次看到它。

111
00:05:29,900 --> 00:05:31,210
然后它会再次获取它

112
00:05:31,210 --> 00:05:32,923
再存放一分钟。

113
00:05:34,330 --> 00:05:37,260
但是使用刷新按钮刷新应该可以。

114
00:05:37,260 --> 00:05:39,630
我们应该总是能够做到这一点。

115
00:05:39,630 --> 00:05:41,590
因此，为了实现这一点，

116
00:05:41,590 --> 00:05:44,570
我实际上会稍微改变一下这个动作

117
00:05:44,570 --> 00:05:47,370
并期待一个有效载荷，

118
00:05:47,370 --> 00:05:49,430
它拥有一个告诉我的属性

119
00:05:49,430 --> 00:05:52,030
我绝对必须再次取回。

120
00:05:52,030 --> 00:05:55,320
所以它基本上覆盖了分散。

121
00:05:55,320 --> 00:05:58,710
在这里，我们可以简单地在此添加一个额外的检查

122
00:05:58,710 --> 00:06:01,070
如果条件在这里，并检查是否

123
00:06:01,070 --> 00:06:06,070
假设有效负载具有错误的刷新属性，

124
00:06:07,460 --> 00:06:09,260
如果没有，

125
00:06:09,260 --> 00:06:13,180
如果这是错误的，我们不应该更新，

126
00:06:13,180 --> 00:06:15,080
然后我们跳过这个。

127
00:06:15,080 --> 00:06:19,310
否则，如果 do 为真或此为真，

128
00:06:19,310 --> 00:06:22,343
如果检查将被跳过，我们将再次获取。

129
00:06:23,660 --> 00:06:28,370
所以现在我们将能够设置一个错误的刷新有效载荷

130
00:06:28,370 --> 00:06:29,420
到这个动作。

131
00:06:29,420 --> 00:06:32,270
如果它是真的，我们将再次获取，

132
00:06:32,270 --> 00:06:35,040
不管是多于还是少于一分钟前，

133
00:06:35,040 --> 00:06:36,283
自从我们上次这样做以来。

134
00:06:37,970 --> 00:06:40,340
现在我们只需要确保这个有效载荷被传递

135
00:06:40,340 --> 00:06:41,660
进入这个动作。

136
00:06:41,660 --> 00:06:44,070
为此，我们可以去教练名单，

137
00:06:44,070 --> 00:06:46,550
这是发送此操作的位置。

138
00:06:46,550 --> 00:06:49,840
在负载教练这里,

139
00:06:49,840 --> 00:06:52,900
我们现在想传递这个有效载荷。

140
00:06:52,900 --> 00:06:56,103
错误的刷新键。

141
00:06:57,600 --> 00:06:58,960
这应该是假的，

142
00:06:58,960 --> 00:07:02,000
如果从内部调用负载捕获

143
00:07:02,000 --> 00:07:03,730
那里创建了生命周期钩子，

144
00:07:03,730 --> 00:07:06,690
因为我想使用缓存，

145
00:07:06,690 --> 00:07:08,990
但假刷新应该是真的，

146
00:07:08,990 --> 00:07:10,870
如果这是通过按钮调用的

147
00:07:10,870 --> 00:07:13,803
通过模板中的这个刷新按钮。

148
00:07:14,960 --> 00:07:17,380
所以我们只需要做这个负载

149
00:07:18,420 --> 00:07:21,360
教练的方法更灵活一点。

150
00:07:21,360 --> 00:07:24,000
我们可以添加一个刷新参数

151
00:07:24,000 --> 00:07:26,793
并将其设置为 false 作为默认值。

152
00:07:27,760 --> 00:07:31,310
这是受支持的现代 JavaScript 语法

153
00:07:31,310 --> 00:07:34,680
并提供、刷新此参数

154
00:07:34,680 --> 00:07:37,593
作为我们的有效负载中错误刷新的值。

155
00:07:38,730 --> 00:07:43,290
这样一来，如果我们不带参数地调用负载教练，

156
00:07:43,290 --> 00:07:46,430
将使用默认值 false，

157
00:07:46,430 --> 00:07:49,630
但我们可以忽略所有呼叫负载教练

158
00:07:49,630 --> 00:07:51,070
当我们点击按钮

159
00:07:51,070 --> 00:07:55,453
手动传入true，false为刷新。

160
00:07:57,470 --> 00:08:01,090
因此，如果我们这样做并保存并重新加载，

161
00:08:01,090 --> 00:08:04,320
它最初获取这个是因为时间已经过去了，

162
00:08:04,320 --> 00:08:05,510
但此后没有。

163
00:08:05,510 --> 00:08:08,030
但是如果我点击刷新，我们会强制

164
00:08:08,030 --> 00:08:09,940
我们确实刷新了一切

165
00:08:09,940 --> 00:08:12,090
并再次加载我们的数据。

166
00:08:12,090 --> 00:08:15,700
这只是一个微小的调整和可选的添加，

167
00:08:15,700 --> 00:08:17,500
但我认为这很有意义。

168
00:08:17,500 --> 00:08:19,700
它希望向您展示您可以做什么

169
00:08:19,700 --> 00:08:22,970
Vue，一个后端和 Vue X。

170
00:08:22,970 --> 00:08:25,290
当然，这只是冰山一角。

171
00:08:25,290 --> 00:08:26,840
你可以做的远不止这些。