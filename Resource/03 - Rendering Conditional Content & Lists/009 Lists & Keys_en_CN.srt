1
00:00:02,160 --> 00:00:04,830
我们几乎完成了 VF 和 V-for，

2
00:00:04,830 --> 00:00:08,640
但这是与 V-for 相关的一项重要补充

3
00:00:08,640 --> 00:00:11,600
你必须知道，因为...

4
00:00:11,600 --> 00:00:16,219
好吧，如果你不知道的话，你会看到奇怪的钱。

5
00:00:16,219 --> 00:00:19,760
让我们在这里说我们的目标和索引

6
00:00:19,760 --> 00:00:23,520
实际上是在一个段落中，在列表项的内部。

7
00:00:23,520 --> 00:00:24,663
所以它看起来像这样。

8
00:00:26,070 --> 00:00:31,070
因此，如果我，这里的 Vue 大师，我们会这样看。

9
00:00:32,150 --> 00:00:35,447
现在让我们说除此之外，我们这里也有输入

10
00:00:37,860 --> 00:00:39,333
我们可以在其中输入一些文本。

11
00:00:40,350 --> 00:00:42,200
我们还要确保

12
00:00:42,200 --> 00:00:44,150
我们实际上可以在这里输入一些东西，

13
00:00:44,150 --> 00:00:47,780
因为现在，如果我重新加载并添加它，

14
00:00:47,780 --> 00:00:49,730
每当我点击那里，你就会看到，

15
00:00:49,730 --> 00:00:53,140
我还单击了列表项，因此将其删除。

16
00:00:53,140 --> 00:00:56,300
我们可以通过在此处添加点击监听器来避免这种情况，

17
00:00:56,300 --> 00:00:58,603
我们在其中添加停止修饰符。

18
00:00:59,460 --> 00:01:01,720
你之前了解过事件修饰符，

19
00:01:01,720 --> 00:01:03,940
这会停止传播。

20
00:01:03,940 --> 00:01:06,830
所以它确保当我们点击输入时，

21
00:01:06,830 --> 00:01:09,240
点击只在那里处理

22
00:01:09,240 --> 00:01:12,793
并且不会触发列表项上的光盘点击事件。

23
00:01:14,030 --> 00:01:17,670
我们不必指定任何应该执行的代码

24
00:01:17,670 --> 00:01:21,060
如果我们想做的就是停止活动。

25
00:01:21,060 --> 00:01:25,250
所以现在如果我重新加载，我们可以主视图，

26
00:01:25,250 --> 00:01:27,300
点击那里并输入。

27
00:01:27,300 --> 00:01:31,070
但我这样做并不是为了向你展示停止修饰符，

28
00:01:31,070 --> 00:01:32,750
尽管很高兴知道。

29
00:01:32,750 --> 00:01:35,520
而不是让我告诉你一个奇怪的错误

30
00:01:35,520 --> 00:01:38,103
你可以体验到。

31
00:01:39,440 --> 00:01:44,440
我还要补充，完成课程作为另一个目标，

32
00:01:46,090 --> 00:01:51,090
现在我将在这里输入一些东西。

33
00:01:53,300 --> 00:01:54,730
所以在第一个目标。

34
00:01:54,730 --> 00:01:57,913
现在单击它，以便删除此目标。

35
00:01:58,910 --> 00:02:00,180
这不是很奇怪吗？

36
00:02:00,180 --> 00:02:03,740
第二个目标仍然存在。

37
00:02:03,740 --> 00:02:05,120
第一个被删了。

38
00:02:05,120 --> 00:02:07,490
所以新的第一个是旧的第二个

39
00:02:07,490 --> 00:02:09,870
它保留了一些东西。

40
00:02:09,870 --> 00:02:13,580
可能看起来像一个很酷的功能，但它实际上是一个降压。

41
00:02:13,580 --> 00:02:15,040
这可能会变得更加明显

42
00:02:15,040 --> 00:02:17,830
如果我重新加载并再试一次。

43
00:02:17,830 --> 00:02:20,540
Vue 大师，完成课程

44
00:02:20,540 --> 00:02:22,630
现在让我们反过来做。

45
00:02:22,630 --> 00:02:24,990
让我们在第二个目标中输入一些内容

46
00:02:24,990 --> 00:02:26,863
并删除第一个。

47
00:02:28,830 --> 00:02:30,530
现在完成课程，

48
00:02:30,530 --> 00:02:34,110
几秒钟前在此输入字段中有内容

49
00:02:34,110 --> 00:02:36,300
直到我们删除了第一个目标。

50
00:02:36,300 --> 00:02:38,340
现在旧的第二个目标，

51
00:02:38,340 --> 00:02:40,820
完成课程，是新的第一目标，

52
00:02:40,820 --> 00:02:44,780
但它丢失了我们在这些输入字段中的输入。

53
00:02:44,780 --> 00:02:47,830
这绝对不是你想要的。

54
00:02:47,830 --> 00:02:50,740
你可以说这是一个小众场景，

55
00:02:50,740 --> 00:02:54,420
但导致这个的问题实际上是一个更大的问题，

56
00:02:54,420 --> 00:02:56,830
这也可能导致性能问题

57
00:02:56,830 --> 00:02:59,430
如果你没有正确修复它。

58
00:02:59,430 --> 00:03:01,300
这里的问题很简单，

59
00:03:01,300 --> 00:03:05,120
当你添加和删除项目时，Vue 会更新列表，

60
00:03:05,120 --> 00:03:07,300
它在真实的 Dom 中呈现列表

61
00:03:07,300 --> 00:03:09,610
并根据需要进行更新。

62
00:03:09,610 --> 00:03:14,480
它试图这样做以优化性能。

63
00:03:14,480 --> 00:03:18,620
这也意味着它重用了 Dom 元素。

64
00:03:18,620 --> 00:03:23,620
所以如果我们在这里有两个目标，两个 Dom 元素

65
00:03:24,010 --> 00:03:26,340
我删除了第一个，

66
00:03:26,340 --> 00:03:29,640
Vue 实际上不会重新渲染整个列表。

67
00:03:29,640 --> 00:03:32,550
它也不会删除第一个 Dom 元素68
00:03:32,550 --> 00:03:34,350
并移动到第二个周围。

69
00:03:34,350 --> 00:03:38,620
相反，它基本上采用了第二个元素的内容

70
00:03:38,620 --> 00:03:41,620
并将其移动到第一个 Dom 元素中。

71
00:03:41,620 --> 00:03:46,620
这就解释了为什么如果我在这里输入一些文字，

72
00:03:47,260 --> 00:03:50,880
如果我删除第一个元素，该文本将丢失。

73
00:03:50,880 --> 00:03:54,130
因为第一个 Dom 元素实际上并没有被移除

74
00:03:54,130 --> 00:03:56,420
而不是第二个的内容。

75
00:03:56,420 --> 00:03:59,150
对于内容，我指的是动态内容。

76
00:03:59,150 --> 00:04:01,400
所以这个带花括号的部分，

77
00:04:01,400 --> 00:04:04,243
被移动到旧的第一个 Dom 元素中。

78
00:04:05,380 --> 00:04:08,460
第一个 Dom 元素中的输入元素

79
00:04:08,460 --> 00:04:10,280
仍然是旧的

80
00:04:10,280 --> 00:04:14,960
因为整个列表项仍然是旧的第一个元素。

81
00:04:14,960 --> 00:04:18,310
只是动态内容被移动了

82
00:04:18,310 --> 00:04:20,579
这就是我们失去输入的原因

83
00:04:20,579 --> 00:04:22,470
我们有第二个元素

84
00:04:22,470 --> 00:04:24,470
当第二个元素的内容

85
00:04:24,470 --> 00:04:27,623
移动到旧的第一个元素的 Dom 元素。

86
00:04:28,680 --> 00:04:31,663
我希望我能弄清楚这里的问题是什么。

87
00:04:33,080 --> 00:04:36,140
现在发生这种情况是因为 Vue 重用了这些元素，

88
00:04:36,140 --> 00:04:38,430
这通常是好的。

89
00:04:38,430 --> 00:04:43,080
但有时它需要能够区分元素。

90
00:04:43,080 --> 00:04:46,430
现在的问题是因为它们都有相同的元素，

91
00:04:46,430 --> 00:04:50,300
同一个Dom元素，都是LI元素。

92
00:04:50,300 --> 00:04:53,850
没有唯一的识别标准

93
00:04:53,850 --> 00:04:56,020
对于每个渲染的 Dom 元素。

94
00:04:56,020 --> 00:04:58,010
是的，内容不同，

95
00:04:58,010 --> 00:05:00,810
但值得庆幸的是 Vue 没有继续前进

96
00:05:00,810 --> 00:05:03,770
并将所有内容相互比较。

97
00:05:03,770 --> 00:05:06,860
那将是超级性能密集型的。

98
00:05:06,860 --> 00:05:08,490
相反，长话短说，

99
00:05:08,490 --> 00:05:11,380
有一个简单的额外属性，

100
00:05:11,380 --> 00:05:15,080
这是一个非默认的 HTML 属性，

101
00:05:15,080 --> 00:05:20,050
您可以在也使用 V-for 的元素上添加它。

102
00:05:20,050 --> 00:05:22,443
这就是关键属性。

103
00:05:23,290 --> 00:05:24,670
关键属性，

104
00:05:24,670 --> 00:05:28,830
我要再说一遍，它不是默认的 HTML 属性，

105
00:05:28,830 --> 00:05:33,340
相反，它是 Vue 理解和检测的属性。

106
00:05:33,340 --> 00:05:36,470
它是可选的，但添加它是个好主意

107
00:05:36,470 --> 00:05:38,490
每当您使用 V-for。

108
00:05:38,490 --> 00:05:41,000
实际上你也会在课程的后期

109
00:05:41,000 --> 00:05:44,390
看到有很多场景你必须使用它。

110
00:05:44,390 --> 00:05:48,680
所以在所有项目上开始使用它已经是一个好习惯

111
00:05:48,680 --> 00:05:50,960
你在哪里使用 V-for。

112
00:05:50,960 --> 00:05:55,020
和关键，一旦一个唯一的识别标准

113
00:05:55,020 --> 00:05:57,900
对于它在这里输出的每个项目。

114
00:05:57,900 --> 00:06:02,060
因此，我们想用 V-bind 将它绑定到一个动态值

115
00:06:02,060 --> 00:06:05,090
或短端，只是一个冒号。

116
00:06:05,090 --> 00:06:06,910
现在在这里，我们需要一些东西

117
00:06:06,910 --> 00:06:09,523
唯一标识每个目标。

118
00:06:10,710 --> 00:06:13,920
你可能倾向于说索引做到了

119
00:06:13,920 --> 00:06:16,560
因为每个目标都有自己的索引。

120
00:06:16,560 --> 00:06:20,460
但是，请记住，如果我有两个目标

121
00:06:20,460 --> 00:06:22,530
我删除了第一个，

122
00:06:22,530 --> 00:06:25,800
旧的第二个现在索引为零。

123
00:06:25,800 --> 00:06:29,130
索引并不真正属于目标内容。

124
00:06:29,130​​ --> 00:06:31,500
索引始终相同。

125
00:06:31,500 --> 00:06:35,490
例如，第一项总是索引为零。

126
00:06:35,490 --> 00:06:39,070
所以索引并不严格附加到元素值

127
00:06:39,070 --> 00:06:40,490
在数组中。

128
00:06:40,490 --> 00:06:43,950
所以在这里使用索引并不是一个好东西。

129
00:06:43,950 --> 00:06:47,640
相反，在这种情况下，我们可以使用目标文本本身。

130
00:06:47,640 --> 00:06:49,880
当然我们可以输入相同的目标文本

131
00:06:49,880 --> 00:06:52,940
这里不止一次，但让我们假设情况并非如此。

132
00:06:52,940 --> 00:06:54,293
这n 目标很好。

133
00:06:55,150 --> 00:06:58,380
更现实的例子是 ID

134
00:06:58,380 --> 00:07:02,740
例如，您可能已经在您的数据库中。

135
00:07:02,740 --> 00:07:04,440
你会在课程的后面看到，

136
00:07:04,440 --> 00:07:07,870
一旦我们还与后端和数据库通信，

137
00:07:07,870 --> 00:07:11,460
在大多数情况下，您确实有一个唯一的 ID。

138
00:07:11,460 --> 00:07:15,020
所以为每个列表项获取这样一个唯一的键，

139
00:07:15,020 --> 00:07:17,523
实际上并不太难。

140
00:07:19,100 --> 00:07:21,530
但在这里我将简单地使用目标文本。

141
00:07:21,530 --> 00:07:25,600
如果我现在重新加载并进入，完成课程

142
00:07:25,600 --> 00:07:27,663
和 Vue 大师，

143
00:07:28,650 --> 00:07:30,780
你会看到，如果我在这里输入一些东西

144
00:07:30,780 --> 00:07:34,260
在第二个目标，然后我删除第一个，

145
00:07:34,260 --> 00:07:38,080
现在输入与第二个一起移动。

146
00:07:38,080 --> 00:07:40,660
因为现在 Vue 能够分辨

147
00:07:40,660 --> 00:07:43,150
不同的 Dom 元素分开

148
00:07:43,150 --> 00:07:46,000
并检测到第一个 Dom 元素

149
00:07:46,000 --> 00:07:49,660
现在需要删除，以免丢失任何数据

150
00:07:49,660 --> 00:07:51,493
附加到第二个元素。

151
00:07:52,430 --> 00:07:55,410
这是一个非常彻底和冗长的解释

152
00:07:55,410 --> 00:07:57,630
有很多幕后的东西。

153
00:07:57,630 --> 00:07:59,880
如果有一个关键点，

154
00:07:59,880 --> 00:08:04,210
再次，没有双关语，你应该添加这样一个键

155
00:08:04,210 --> 00:08:06,810
具有独特的识别标准

156
00:08:06,810 --> 00:08:09,210
当您使用 V-for 时。

157
00:08:09,210 --> 00:08:11,660
你应该添加它来帮助 Vue

158
00:08:11,660 --> 00:08:13,550
区分不同的元素

159
00:08:13,550 --> 00:08:17,440
并确保状态像这样输入的值

160
00:08:17,440 --> 00:08:18,930
不会迷路。

161
00:08:18,930 --> 00:08:22,120
并在幕后为您提供帮助，

162
00:08:22,120 --> 00:08:24,630
做更多的性能优化。