1
00:00:02,490 --> 00:00:04,740
现在我们了解了计算属性，

2
00:00:04,740 --> 00:00:07,920
输出动态值的关键特性

3
00:00:07,920 --> 00:00:10,570
取决于多个输入值，

4
00:00:10,570 --> 00:00:13,800
或者在这种情况下，在一个输入值上

5
00:00:13,800 --> 00:00:16,239
和一个硬编码值。

6
00:00:16,239 --> 00:00:19,840
他们都是这一切，从不反应特性

7
00:00:19,840 --> 00:00:23,790
内置在 Vue 中，那就是观察者。

8
00:00:23,790 --> 00:00:25,860
什么是观察者？

9
00:00:25,860 --> 00:00:29,020
好吧，观察者基本上是一个函数

10
00:00:29,020 --> 00:00:32,040
你可以告诉 Vue 执行，

11
00:00:32,040 --> 00:00:34,750
当其依赖项之一发生更改时。

12
00:00:34,750 --> 00:00:37,670
好吧，这听起来就像计算属性，

13
00:00:37,670 --> 00:00:39,060
不是吗？

14
00:00:39,060 --> 00:00:41,430
好吧，确实你可以使用 Watchers

15
00:00:41,430 --> 00:00:43,730
而不是计算属性

16
00:00:43,730 --> 00:00:45,820
这就是它的工作原理，

17
00:00:45,820 --> 00:00:47,973
以及为什么你可能不想这样做。

18
00:00:48,900 --> 00:00:53,900
让我在这里添加一个全名，数据属性，如下所示，

19
00:00:54,210 --> 00:00:57,440
因此让我们注释掉这个全名，

20
00:00:57,440 --> 00:01:00,910
计算属性，这样我们就不会发生名称冲突。

21
00:01:00,910 --> 00:01:04,129
您不想使用计算属性和数据属性

22
00:01:04,129 --> 00:01:05,212
同名。

23
00:01:06,120 --> 00:01:08,620
现在我们可以在这里添加一个新的配置，

24
00:01:08,620 --> 00:01:12,520
我们传递给创建应用程序的这个对象的一个​​新选项，

25
00:01:12,520 --> 00:01:15,850
再次在他们的任何地方，位置都无关紧要。

26
00:01:15,850 --> 00:01:17,170
我这里加一下

27
00:01:17,170 --> 00:01:22,170
这就是 watch 选项，就像计算的数据一样

28
00:01:22,430 --> 00:01:24,530
和方法，这个名字不取决于你

29
00:01:24,530 --> 00:01:27,270
这是 Vue 支持的功能之一，

30
00:01:27,270 --> 00:01:29,393
因此必须注意这一点。

31
00:01:30,350 --> 00:01:34,960
Watch 需要一个对象，就像计算和方法一样。

32
00:01:34,960 --> 00:01:36,340
而且，再一次，

33
00:01:36,340 --> 00:01:39,150
你会定义一堆方法。

34
00:01:39,150 --> 00:01:44,150
准确地说，您现在可以使用名称

35
00:01:44,550 --> 00:01:47,900
您在数据或计算属性中使用

36
00:01:47,900 --> 00:01:51,020
作为观察者方法的名称。

37
00:01:51,020 --> 00:01:51,853
例如，

38
00:01:51,853 --> 00:01:53,450
在这里我们可以使用名称，

39
00:01:53,450 --> 00:01:55,750
因为我们有那个 name 数据属性

40
00:01:55,750 --> 00:01:59,040
并将其定义为 watch 中的方法。

41
00:01:59,040 --> 00:02:00,220
从技术上讲，这没问题，

42
00:02:00,220 --> 00:02:03,020
我们在这里不会有任何名称冲突。

43
00:02:03,020 --> 00:02:06,320
这告诉了 Vue 一件重要的事情。

44
00:02:06,320 --> 00:02:11,320
每当名称更改时，此观察程序方法将重新执行

45
00:02:13,320 --> 00:02:15,150
这真的很重要。

46
00:02:15,150 --> 00:02:19,330
这里使用的这个名称建立了这个连接。

47
00:02:19,330 --> 00:02:20,820
这就是观察者的工作方式。

48
00:02:20,820 --> 00:02:25,030
您重复另一个数据或计算的属性名称

49
00:02:25,030 --> 00:02:28,000
在观察者方法中作为方法名称，

50
00:02:28,000 --> 00:02:29,323
当你这样做时，

51
00:02:29,323 --> 00:02:34,000
该 watcher 方法将由 Vue 自动执行，

52
00:02:34,000 --> 00:02:37,440
每当该名称的财产，

53
00:02:37,440 --> 00:02:41,250
所以这种情况下，只要 name 属性发生变化。

54
00:02:41,250 --> 00:02:44,110
我们也可以看柜台财产，

55
00:02:44,110 --> 00:02:46,730
但在这里我想看名字。

56
00:02:46,730 --> 00:02:50,100
然后在这里我们可以指定我们想要的任何逻辑。

57
00:02:50,100 --> 00:02:53,290
我们不返回任何东西，因为我们不会使用

58
00:02:53,290 --> 00:02:58,090
观察者在我们的 HTML 代码中的任何地方使用一个返回值。

59
00:02:58,090 --> 00:03:01,270
相反，在这里我们运行应该执行的逻辑

60
00:03:01,270 --> 00:03:02,740
改名的时候。

61
00:03:02,740 --> 00:03:03,573
例如，

62
00:03:03,573 --> 00:03:05,947
我们可以在这里更新全名，并设置它，

63
00:03:05,947 --> 00:03:10,023
= to this.name + 一个空格 + Schwartzmuller。

64
00:03:12,170 --> 00:03:16,170
实际上，我们甚至不需要在这里引用 this.name，

65
00:03:16,170 --> 00:03:19,870
观察者函数自动获取最后一个值，

66
00:03:19,870 --> 00:03:24,530
watch 属性的最新值作为参数。

67
00:03:24,530 --> 00:03:26,980
这是 Vue 自动传入的，

68
00:03:26,980 --> 00:03:29,930
这个最新值的手表属性。

69
00:03:29,930 --> 00:03:32,050
因此，我们可以接受它作为一个论点，

70
00:03:32,050 --> 00:03:34,943
随心所欲地命名它，然后在这里使用它。

71
00:03:35,930 --> 00:03:39,610
我们实际上也可以在这里接受第二个论点，

72
00:03:39,610 --> 00:03:43,840
除了值之外，那将是以前的值，

73
00:03:43,840 --> 00:03:46,590
手表属性的旧值。

74
00:03:46,590 --> 00:03:48,060
在这里我只接受一个

75
00:03:48,060 --> 00:03:49,710
因为我们只需要那个，

76
00:03:49,710 --> 00:03:53,060
但如果你愿意，你可以接受两个论点。

77
00:03:53,060 --> 00:03:55,113
新价值和旧价值。

78
00:03:56,250 --> 00:03:59,210
并且我们还将更新全名

79
00:03:59,210 --> 00:04:01,330
每当名称更改时。

80
00:04:01,330 --> 00:04:04,570
如果我们保存并重新加载，确实，如果我在这里输入，

81
00:04:04,570 --> 00:04:08,300
您的行为与以前相同，但有一个不同

82
00:04:08,300 --> 00:04:10,560
我们总是在这里看到施瓦茨穆勒，

83
00:04:10,560 --> 00:04:15,350
但我们也可以改变它，检查值是否为空......

84
00:04:15,350 --> 00:04:17,690
这是一个空字符串，如果是这样的话，

85
00:04:17,690 --> 00:04:20,803
我们也将全名设置为空字符串。

86
00:04:20,803 --> 00:04:23,980
这就是我们如何确保全名为空的方式。

87
00:04:23,980 --> 00:04:27,380
如果 value 是空的，当然，

88
00:04:27,380 --> 00:04:30,333
然后，我应该将其他代码放入 Vue 的 else 块中，

89
00:04:31,490 --> 00:04:34,173
现在我们有了所描述的行为。

90
00:04:35,660 --> 00:04:37,280
所以这是一个观察者。

91
00:04:37,280 --> 00:04:38,113
如你所见，

92
00:04:38,113 --> 00:04:41,523
您可以将其用作计算属性的替代方案。

93
00:04:42,370 --> 00:04:44,110
现在我们有几个问题

94
00:04:44,110 --> 00:04:46,090
如果我们使用它，

95
00:04:46,090 --> 00:04:46,923
一方面，

96
00:04:46,923 --> 00:04:49,790
我认为计算属性的概念

97
00:04:49,790 --> 00:04:52,920
可能更容易理解，

98
00:04:52,920 --> 00:04:57,610
但更大的问题出现了如果我们有电脑财产

99
00:04:57,610 --> 00:05:00,710
这将使用多个依赖项，

100
00:05:00,710 --> 00:05:04,540
假设我们有第二个输入。

101
00:05:04,540 --> 00:05:06,680
我只是在这里复制了我的输入，

102
00:05:06,680 --> 00:05:09,403
我们有一个姓氏。

103
00:05:10,770 --> 00:05:13,540
现在我们添加一个新的数据属性，

104
00:05:13,540 --> 00:05:16,030
姓氏，最初是一个空字符串，

105
00:05:16,030 --> 00:05:19,873
这与第二个输入上的模型绑定。

106
00:05:21,410 --> 00:05:23,600
现在我们有了这两个名字。

107
00:05:23,600 --> 00:05:27,790
现在我们想在名字的时候更新全名，

108
00:05:27,790 --> 00:05:29,963
或姓氏已更改。

109
00:05:31,000 --> 00:05:32,770
为了通过观察者实现这一点，

110
00:05:32,770 --> 00:05:36,010
我们需要添加第二个观察者，因为第一个

111
00:05:36,010 --> 00:05:38,103
只是看着名字。

112
00:05:39,020 --> 00:05:40,860
现在我们需要添加第二个

113
00:05:40,860 --> 00:05:45,480
我们还观察姓氏并获取其值。

114
00:05:45,480 --> 00:05:49,300
在这里我们有几乎相同的代码，

115
00:05:49,300 --> 00:05:51,697
但我们想在这里设置全名，

116
00:05:51,697 --> 00:05:56,410
= 到 this.name + 空白 + 丢失 + 值

117
00:05:59,180 --> 00:06:02,320
因为这里我们得到了 last name 的最新值

118
00:06:02,320 --> 00:06:04,980
在我们的第一个观察者那里，

119
00:06:04,980 --> 00:06:09,430
我们想把它改成 value + blank + this.last name

120
00:06:09,430 --> 00:06:11,650
因为我们在这里看名字。

121
00:06:11,650 --> 00:06:16,650
现在我们有两个观察者来反映全名，

122
00:06:17,210 --> 00:06:19,623
它通过两个输入进行管理。

123
00:06:20,640 --> 00:06:23,860
是的，这行得通，但它有很多代码，

124
00:06:23,860 --> 00:06:27,120
特别是如果我们将其与计算属性进行比较

125
00:06:27,120 --> 00:06:28,850
选择。

126
00:06:28,850 --> 00:06:33,303
让我注释掉全名，数据属性，

127
00:06:35,200 --> 00:06:38,840
让我们也注释掉观察者。

128
00:06:38,840 --> 00:06:40,130
我们可以删除它们，

129
00:06:40,130 --> 00:06:42,840
但我会保留它们以供参考。

130
00:06:42,840 --> 00:06:45,090
让我们带回计算的属性，

131
00:06:45,090 --> 00:06:49,130
看看使用计算属性有多容易。

132
00:06:49,130​​ --> 00:06:52,810
如果我们想使用两个依赖项，

133
00:06:52,810 --> 00:06:56,670
我们像这样简单地引用两个依赖项，

134
00:06:56,670 --> 00:06:58,503
指着这个姓。

135
00:06:59,590 --> 00:07:03,730
现在我们用更少的代码得到了想要的行为。

136
00:07:03,730 --> 00:07:06,170
也许我们也应该在这里调整 df check，

137
00:07:06,170 --> 00:07:10,190
并检查名称是否为空或此姓氏是否为空。

138
00:07:10,190 --> 00:07:11,740
如果两者中的任何一个为空，

139
00:07:11,740 --> 00:07:14,340
我们返回一个空的全名。

140
00:07:14,340 --> 00:07:17,923
但是有了这个，我们得到了想要的行为，

141
00:07:19,320 --> 00:07:21,250
这真的不是很多代码。

142
00:07:21,250 --> 00:07:23,840
就是这个代码来获取全名，

143
00:07:23,840 --> 00:07:28,350
动态地将其与我们的两个观察者进行比较。

144
00:07:28,350 --> 00:07:31,250
如果我们可以使用它们，为什么我们会有观察者，

145
00:07:31,250 --> 00:07:32,960
但他们更糟？

146
00:07:32,960 --> 00:07:36,330
因为这可行，但不是主要场景

147
00:07:36,330 --> 00:07:37,710
用于使用观察者。

148
00:07:37,710 --> 00:07:39,350
观察者很强​​大，

149
00:07:39,350 --> 00:07:43,653
如果你有不同的意图。

150
00:07:45,470 --> 00:07:47,230
让我们回到我们的柜台。

151
00:07:47,230 --> 00:07:52,190
假设当计数器超过 50 时，类似的东西，

152
00:07:52,190 --> 00:07:54,160
我们想重置它。

153
00:07:54,160 --> 00:07:57,840
这就是观察者大放异彩的任务类型。

154
00:07:57,840 --> 00:08:01,040
当事情发生时我们想改变计数器

155
00:08:01,040 --> 00:08:05,850
所以我们可以观察计数器并得到它的最新值，

156
00:08:05,850 --> 00:08:10,160
然后检查是否值，

157
00:08:10,160 --> 00:08:13,300
所以计数器的值大于50，

158
00:08:13,300 --> 00:08:18,273
如果是这样，我们设置 this.counter = 0。

159
00:08:20,780 --> 00:08:24,150
这就是观察者可以提供帮助的事情。

160
00:08:24,150 --> 00:08:25,890
如果你想运行逻辑，

161
00:08:25,890 --> 00:08:29,360
这可能是数据属性的所有更新，

162
00:08:29,360 --> 00:08:31,580
但不应该总是这样做。

163
00:08:31,580 --> 00:08:35,080
例如这里，我只想将计数器设置为零，

164
00:08:35,080 --> 00:08:36,950
如果我们超过 50。

165
00:08:36,950 --> 00:08:40,860
计算属性可能不是最好的

166
00:08:40,860 --> 00:08:43,390
在这里替代这种任务。

167
00:08:43,390 --> 00:08:45,840
您可以尝试使用计算属性解决此问题

168
00:08:45,840 --> 00:08:49,150
你很快就会发现你会在这里遇到一些问题。

169
00:08:49,150 --> 00:08:51,540
有了观察者，这很容易。

170
00:08:51,540 --> 00:08:54,930
如果我们保存它然后重新加载，我们可以更改计数器，

171
00:08:54,930 --> 00:08:57,890
但你会看到我是否再次按加 10

172
00:08:57,890 --> 00:09:01,350
因此谁会超过 50 它又归零

173
00:09:01,350 --> 00:09:03,220
并重新开始。

174
00:09:03,220 --> 00:09:06,390
这就是观察者可以大放异彩的任务。

175
00:09:06,390 --> 00:09:09,940
另一个例子是 HTTP 请求，

176
00:09:09,940 --> 00:09:12,550
如果某些数据发生变化，你想发送，

177
00:09:12,550 --> 00:09:16,890
或您想要设置的计时器，如果某些值发生变化。

178
00:09:16,890 --> 00:09:20,850
例如，在这里，我们可以说如果值超过 50，

179
00:09:20,850 --> 00:09:25,520
我想将计时器设置为两秒，

180
00:09:25,520 --> 00:09:30,250
在两秒后执行的函数中，

181
00:09:30,250 --> 00:09:33,400
我想重置计数器。

182
00:09:33,400 --> 00:09:37,030
像这样，那行不通，因为在这里，

183
00:09:37,030 --> 00:09:39,070
不会指同一件事，

184
00:09:39,070 --> 00:09:42,730
这将指代此功能之外

185
00:09:42,730 --> 00:09:46,980
因此我们可以通过存储来解决这个问题，

186
00:09:46,980 --> 00:09:50,170
this 在许多常量中并在此处使用 that，

187
00:09:50,170 --> 00:09:51,860
这不是 Vue 特定的，

188
00:09:51,860 --> 00:09:53,840
这就是 JavaScript 的工作原理，

189
00:09:53,840 --> 00:09:56,450
这个关键词在那里可能很棘手，

190
00:09:56,450 --> 00:09:58,650
但是如果我重新加载该代码，

191
00:09:58,650 --> 00:10:01,750
如果我加快计时器，它会超过 50，

192
00:10:01,750 --> 00:10:03,890
但它最终会重置。

193
00:10:03,890 --> 00:10:07,830
因为我们在每次计数器改变时设置一个超时

194
00:10:07,830 --> 00:10:09,730
并且大于 50。

195
00:10:09,730 --> 00:10:12,450
顺便说一句，这就是它多次重置的所有原因

196
00:10:12,450 --> 00:10:15,880
在这里，因为如果我超过 50 岁并且我继续前进，

197
00:10:15,880 --> 00:10:18,600
我触发了越来越多的观察者执行

198
00:10:18,600 --> 00:10:21,220
越来越多的计时器被设置。

199
00:10:21,220 --> 00:10:24,540
这是一种任务观察者可能有用

200
00:10:24,540 --> 00:10:28,090
如果你想运行一些代码，可能是，

201
00:10:28,090 --> 00:10:32,570
但不一定也会更新一些数据属性

202
00:10:32,570 --> 00:10:34,950
对属性变化的反应。

203
00:10:34,950 --> 00:10:37,040
如果你想做那个执行代码，

204
00:10:37,040 --> 00:10:40,680
因为有些事情发生了变化，那么观察者可能会有所帮助。

205
00:10:40,680 --> 00:10:44,610
如果您只想动态计算一些输出值，

206
00:10:44,610 --> 00:10:46,853
计算属性是你的朋友。