1
00:00:02,150 --> 00:00:05,400
好吧，你当然可以把你的代码放在这里。

2
00:00:05,400 --> 00:00:09,260
名字加上施瓦茨穆勒，例如，

3
00:00:09,260 --> 00:00:10,990
你可以把它放在这里。

4
00:00:10,990 --> 00:00:14,180
如果你这样做，你就避免了这个问题。

5
00:00:14,180 --> 00:00:17,300
现在视图能够看到这里使用了什么

6
00:00:17,300 --> 00:00:19,610
它只会更新这一段

7
00:00:19,610 --> 00:00:22,106
并且只有在良好的情况下才会重新评估，

8
00:00:22,106 --> 00:00:24,380
在这种情况下，名称已更改

9
00:00:24,380 --> 00:00:26,500
并且输出全名从未调用过

10
00:00:26,500 --> 00:00:29,091
因此永远不会被视图调用。

11
00:00:29,091 --> 00:00:33,110
但是现在我们的 HTML 代码中有更多的逻辑

12
00:00:33,110 --> 00:00:36,320
又是这样，不像你学到的那样好。

13
00:00:36,320 --> 00:00:38,630
所以我们可以使用第三个不错的功能，

14
00:00:38,630 --> 00:00:40,193
计算属性。

15
00:00:41,550 --> 00:00:45,240
计算属性本质上类似于方法

16
00:00:45,240 --> 00:00:48,610
有一个重要的不同观点将意识到

17
00:00:48,610 --> 00:00:52,190
它们的依赖关系，只重新执行它们

18
00:00:52,190 --> 00:00:54,453
如果其中一个依赖项发生了变化。

19
00:00:55,330 --> 00:00:59,370
Computed 是第三大配置选项

20
00:00:59,370 --> 00:01:02,640
我们了解我们创建的应用程序。

21
00:01:02,640 --> 00:01:04,200
第一个是数据。

22
00:01:04,200 --> 00:01:05,850
第二个是方法。

23
00:01:05,850 --> 00:01:07,870
第三个是计算出来的。

24
00:01:07,870 --> 00:01:10,560
您可以在此冲突对象中的任何位置添加它

25
00:01:10,560 --> 00:01:13,770
在这里，我将在方法的数据之间添加它，

26
00:01:13,770 --> 00:01:15,785
但位置无关紧要。

27
00:01:15,785 --> 00:01:20,785
所以你在这里添加计算，就像方法和数据一样。

28
00:01:20,950 --> 00:01:23,240
这不是您可以选择的名称。

29
00:01:23,240 --> 00:01:24,830
这是您必须使用的名称

30
00:01:24,830 --> 00:01:27,600
因为它是关键选项之一，

31
00:01:27,600 --> 00:01:31,640
视图应用程序中的视图支持。

32
00:01:31,640 --> 00:01:35,620
类似计算的方法需要一个对象。

33
00:01:35,620 --> 00:01:38,745
所以你传递一个对象作为一个值来计算它。

34
00:01:38,745 --> 00:01:41,070
现在在计算中，

35
00:01:41,070 --> 00:01:45,430
你定义了一堆方法，就像在方法中一样，

36
00:01:45,430 --> 00:01:48,860
但是您定义和计算的方法将被调用

37
00:01:48,860 --> 00:01:50,760
并以不同的方式执行。

38
00:01:50,760 --> 00:01:53,989
这就是为什么我们有这两个不同的块。

39
00:01:53,989 --> 00:01:58,000
所以在这里我们可以添加一个全名方法，

40
00:01:58,000 --> 00:02:02,250
我将其命名为全名而不是输出全名，

41
00:02:02,250 --> 00:02:04,810
即使我可以，因为这个名字取决于你，

42
00:02:04,810 --> 00:02:08,360
但我这样命名它是因为我们将使用它

43
00:02:08,360 --> 00:02:11,480
像数据属性，而不像方法，

44
00:02:11,480 --> 00:02:13,570
尽管从技术上讲它是一种方法，

45
00:02:13,570 --> 00:02:15,530
但我们不会这样使用它。

46
00:02:15,530 --> 00:02:16,990
我们不会调用它。

47
00:02:16,990 --> 00:02:20,450
因此你应该命名你的计算属性

48
00:02:20,450 --> 00:02:23,623
就像您命名数据属性一样。

49
00:02:25,170 --> 00:02:26,630
而现在在这里，

50
00:02:26,630 --> 00:02:30,760
我们想回到最终应该产生的价值

51
00:02:30,760 --> 00:02:32,630
通过该计算属性

52
00:02:32,630 --> 00:02:35,800
在那里我将复制完全相同的代码

53
00:02:35,800 --> 00:02:38,700
我在我的输出全名方法中有。

54
00:02:38,700 --> 00:02:42,360
因此，我将复制该代码并将其放入其中。

55
00:02:42,360 --> 00:02:45,890
现在，正如我提到的，我们可以使用这个全名，

56
00:02:45,890 --> 00:02:50,700
我们的 HTML 代码中的计算属性是这样的。

57
00:02:50,700 --> 00:02:51,960
这很重要。

58
00:02:51,960 --> 00:02:55,460
不是这样没有括号，

59
00:02:55,460 --> 00:02:57,010
你不叫它

60
00:02:57,010 --> 00:03:01,350
您只需指向它并查看我们会为您调用它。

61
00:03:01,350 --> 00:03:05,010
我们像使用数据属性一样使用它

62
00:03:05,010 --> 00:03:07,060
喜欢在这里反击。

63
00:03:07,060 --> 00:03:10,870
这就是为什么我们还应该命名我们的计算属性

64
00:03:10,870 --> 00:03:12,320
像数据属性，

65
00:03:12,320 --> 00:03:15,670
因为我们使用它们就像变量一样的属性。

66
00:03:15,670 --> 00:03:17,593
我们不会像函数一样使用它们。

67
00:03:18,790 --> 00:03:21,300
所以这里会连上全名

68
00:03:21,300 --> 00:03:23,460
对这个全名计算 p属性

69
00:03:23,460 --> 00:03:26,020
所以名称当然必须相同。

70
00:03:26,020 --> 00:03:28,761
现在视图将为您执行此操作。

71
00:03:28,761 --> 00:03:30,380
它基本上会检查

72
00:03:30,380 --> 00:03:32,590
如果有全名数据属性。

73
00:03:32,590 --> 00:03:34,260
如果没有，它会检查

74
00:03:34,260 --> 00:03:36,940
如果可能存在名称为计算属性

75
00:03:36,940 --> 00:03:39,410
如果是这种情况，它将执行它。

76
00:03:39,410 --> 00:03:42,070
因此，如果我在这里重新加载时救了我们，

77
00:03:42,070 --> 00:03:44,100
我们最初在这里什么也看不到。

78
00:03:44,100 --> 00:03:45,980
但当我开始打字时，

79
00:03:45,980 --> 00:03:48,570
我们看到全名再次出现。

80
00:03:48,570 --> 00:03:50,585
所以我们有和以前一样的行为，

81
00:03:50,585 --> 00:03:53,150
但现在有一个重要的区别，

82
00:03:53,150 --> 00:03:55,253
让我们再次检查开发人员工具。

83
00:03:56,680 --> 00:03:58,770
如果我重新加载，

84
00:03:58,770 --> 00:04:03,250
你会注意到最初当然会再次运行一次，

85
00:04:03,250 --> 00:04:07,020
因为它需要评估全名返回的值

86
00:04:07,020 --> 00:04:09,923
当应用程序首次呈现谨慎时。

87
00:04:10,788 --> 00:04:15,130
但现在如果我清除它，如果我改变我的计数器，

88
00:04:15,130 --> 00:04:18,450
我们看不到再次运行并记住

89
00:04:18,450 --> 00:04:20,450
用一种方法，我们确实看到了，

90
00:04:20,450 --> 00:04:22,860
但现在情况不再如此。

91
00:04:22,860 --> 00:04:25,540
我们只有在这里输入才能看到它，

92
00:04:25,540 --> 00:04:28,690
这很有意义，因为在这里我们真的改变了

93
00:04:28,690 --> 00:04:31,550
该计算属性中使用的东西。

94
00:04:31,550 --> 00:04:34,203
我们每次击键都会更改名称。

95
00:04:34,203 --> 00:04:37,030
所以有了电脑的属性，

96
00:04:37,030 --> 00:04:41,210
视图知道依赖关系

97
00:04:41,210 --> 00:04:42,900
关闭计算机属性。

98
00:04:42,900 --> 00:04:46,460
所以在这种情况下，这个名字是一个依赖

99
00:04:46,460 --> 00:04:50,760
它会缓存计算的属性值

100
00:04:50,760 --> 00:04:54,460
并且只重新计算和重新评估它

101
00:04:54,460 --> 00:04:56,940
如果这种情况下的依赖项之一，

102
00:04:56,940 --> 00:05:01,340
我们更改了 name 属性的唯一依赖项。

103
00:05:01,340 --> 00:05:04,410
这就是性能的关键区别。

104
00:05:04,410 --> 00:05:08,170
最好使用计算机属性的方法

105
00:05:08,170 --> 00:05:11,540
用于输出值 在大多数情况下。

106
00:05:11,540 --> 00:05:15,820
仅当您知道要重新计算时才使用方法

107
00:05:15,820 --> 00:05:19,460
页面上任何内容发生更改时的值。

108
00:05:19,460 --> 00:05:22,300
在大多数情况下，情况并非如此。

109
00:05:22,300 --> 00:05:25,659
您只想重新计算一个值

110
00:05:25,659 --> 00:05:26,492
如果依赖项发生了变化。

111
00:05:26,492 --> 00:05:28,680
这就是计算属性大放异彩的时候。

112
00:05:28,680 --> 00:05:32,560
你仍然需要方法，因为你有一些东西

113
00:05:32,560 --> 00:05:36,040
你真的想在任何事情发生变化时重新执行

114
00:05:36,040 --> 00:05:39,860
或者更多时候，因为你有活动

115
00:05:39,860 --> 00:05:43,450
并且您想在事件发生时触发某些方法，

116
00:05:43,450 --> 00:05:45,000
这不会改变。

117
00:05:45,000 --> 00:05:47,490
您仍然将事件绑定到方法。

118
00:05:47,490 --> 00:05:50,330
您不会将事件绑定到计算机属性。

119
00:05:50,330 --> 00:05:53,120
你真的只使用电脑属性

120
00:05:53,120 --> 00:05:56,453
用于输出类似此处的全名。