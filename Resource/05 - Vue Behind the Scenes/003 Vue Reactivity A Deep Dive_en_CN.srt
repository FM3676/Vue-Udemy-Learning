1
00:00:02,050 --> 00:00:04,207
一秒钟，我将离开Vue

2
00:00:04,207 --> 00:00:06,830
潜入那个代理的东西，

3
00:00:06,830 --> 00:00:08,790
它内置在 JavaScript 中，

4
00:00:08,790 --> 00:00:10,880
Vue 使用的。

5
00:00:10,880 --> 00:00:13,690
让我们离开 Vue 世界

6
00:00:13,690 --> 00:00:15,850
并编写一些普通的 JavaScript。

7
00:00:15,850 --> 00:00:17,530
我们有一个可变消息

8
00:00:17,530 --> 00:00:18,870
我在哪里说你好！

9
00:00:18,870 --> 00:00:21,710
所以这是一个常规的 JavaScript 变量。

10
00:00:21,710 --> 00:00:24,130
它与 Vue 无关。

11
00:00:24,130 --> 00:00:26,380
现在，关于 JavaScript 的有趣之处

12
00:00:26,380 --> 00:00:30,363
是如果我现在有一个新的longMessage，

13
00:00:32,170 --> 00:00:34,240
这是我的旧信息

14
00:00:34,240 --> 00:00:36,830
再加上世界，

15
00:00:36,830 --> 00:00:40,210
我当然可以在这里 console.log

16
00:00:40,210 --> 00:00:42,420
我们会看到你好！世界！

17
00:00:42,420 --> 00:00:46,270
如果我保存它，打开控制台，

18
00:00:46,270 --> 00:00:49,390
并重新加载，我们看到你好！世界！这里。

19
00:00:49,390 --> 00:00:52,010
现在这不应该太令人惊讶。

20
00:00:52,010 --> 00:00:54,580
但是现在如果我们此后更改消息

21
00:00:55,440 --> 00:01:00,090
你好和几个感叹号，

22
00:01:00,090 --> 00:01:04,959
如果我再次 console.log longMessage

23
00:01:04,959 --> 00:01:07,900
我重新加载，我仍然得到你好，世界！

24
00:01:07,900 --> 00:01:10,710
我在这里没有得到所有这些感叹号。

25
00:01:10,710 --> 00:01:15,250
相反，我在 Hello 之后只有一个感叹号！

26
00:01:15,250 --> 00:01:20,180
因为默认情况下 JavaScript 不是响应式的。

27
00:01:20,180 --> 00:01:21,800
那真的只是一些东西

28
00:01:21,800 --> 00:01:23,990
Vue 为我们添加的。

29
00:01:23,990 --> 00:01:26,940
默认情况下，JavaScript 不是响应式的。

30
00:01:26,940 --> 00:01:30,230
如果我们有一个计算，就像我们在这里一样，

31
00:01:30,230 --> 00:01:32,090
我们在哪里使用变量

32
00:01:32,090 --> 00:01:34,640
然后我们改变这个变量，

33
00:01:34,640 --> 00:01:36,710
这里的计算

34
00:01:36,710 --> 00:01:38,530
不会重新执行。

35
00:01:38,530 --> 00:01:41,700
JavaScript 没有注意到消息已更改

36
00:01:41,700 --> 00:01:43,483
并且它在这里被使用过。

37
00:01:45,500 --> 00:01:47,670
这就是 JavaScript 的工作原理

38
00:01:47,670 --> 00:01:49,560
和 Vue 的工作方式不同。

39
00:01:49,560 --> 00:01:51,680
Vue 有一个内置机制

40
00:01:51,680 --> 00:01:54,380
当消息改变时要注意

41
00:01:54,380 --> 00:01:55,840
以便应用程序的某些部分

42
00:01:55,840 --> 00:01:58,850
依赖消息的可以更新。

43
00:01:58,850 --> 00:02:01,870
如前所述，它使用代理。

44
00:02:01,870 --> 00:02:04,723
那么让我们看看代理是如何工作的。

45
00:02:05,860 --> 00:02:07,770
为此，让我删除它

46
00:02:07,770 --> 00:02:11,070
让我们创建一个对象，数据，

47
00:02:11,070 --> 00:02:13,150
这只是一个空的 JavaScript 对象，

48
00:02:13,150 --> 00:02:15,220
再次与 Vue 无关。

49
00:02:15,220 --> 00:02:18,033
让我们把信息放在这里，你好！

50
00:02:20,230 --> 00:02:24,900
现在我们可以用 JavaScript 中的代理包装这个对象

51
00:02:24,900 --> 00:02:27,560
通过创建一个新的代理。

52
00:02:27,560 --> 00:02:30,300
那是一个构造函数

53
00:02:30,300 --> 00:02:32,500
进入现代 JavaScript。

54
00:02:32,500 --> 00:02:34,670
因此，请确保您正在测试此代码

55
00:02:34,670 --> 00:02:37,093
在 Chrome 等现代浏览器中。

56
00:02:38,150 --> 00:02:41,160
现在，我们可以将该代理存储在一个常量中

57
00:02:41,160 --> 00:02:44,610
这个代理想要它应该包装的对象。

58
00:02:44,610 --> 00:02:46,940
在这种情况下，数据。

59
00:02:46,940 --> 00:02:49,380
但它不只是想要这个。

60
00:02:49,380 --> 00:02:53,300
相反，它想要第二个对象作为第二个参数

61
00:02:53,300 --> 00:02:56,760
那将是一个充满处理程序的对象

62
00:02:56,760 --> 00:02:59,120
对于那个包裹的物体。

63
00:02:59,120 --> 00:03:01,080
现在，我将在一秒钟内回到那是什么。

64
00:03:01,080 --> 00:03:05,530
我们首先在这里创建这样一个处理程序对象。

65
00:03:05,530 --> 00:03:09,780
此处理程序对象现在可以使用某些功能。

66
00:03:09,780 --> 00:03:12,720
它可以设置所谓的陷阱，

67
00:03:12,720 --> 00:03:14,920
哪些代理支持。

68
00:03:14,920 --> 00:03:18,530
例如，设置陷阱。

69
00:03:18,530 --> 00:03:21,280
您可以通过在此处添加 set 函数来执行此操作

70
00:03:21,280 --> 00:03:24,090
在处理程序中并作为参数，

71
00:03:24,090 --> 00:03:27,963
你会自动收到一个目标，

72
00:03:28,920 --> 00:03:31,343
一个键和一个值。

73
00:03:32,700 --> 00:03:34,700
现在，要了解它的作用，

74
00:03:34,700 --> 00:03:37,543
让我们 console.log 目标，

75
00:03:40,523 --> 00:03:44,223
这里的关键和价值。

76
00:03:45,390 --> 00:03:47,900
现在让我们传递这个处理程序对象

77
00:03:47,900 --> 00:03:51,960
作为我们代理的第二个参数。

78
00:03:51,960 --> 00:03:54,960
现在，据说代理会包装这个对象，

79
00:03:54,960 --> 00:03:57,110
这个数据对象，第一个参数，

80
00:03:57,110 --> 00:03:58,720
确实如此。

81
00:03:58,720 --> 00:04:03,110
所以在代理上，我们确实可以访问消息

82
00:04:03,110 --> 00:04:06,210
就好像我们有一个 message 属性

83
00:04:06,210 --> 00:04:08,370
在创建的代理对象上

84
00:04:08,370 --> 00:04:09,960
因为实际上，我们会的。

85
00:04:09,960 --> 00:04:11,910
它包装了这个数据对象。

86
00:04:11,910 --> 00:04:13,580
此对象有一条消息。

87
00:04:13,580 --> 00:04:15,623
所以代理也有一个。

88
00:04:16,610 --> 00:04:18,140
我们可以将其设置为 Hello

89
00:04:18,140 --> 00:04:20,700
带有几个感叹号。

90
00:04:20,700 --> 00:04:22,620
现在，让我们保存并重新加载

91
00:04:22,620 --> 00:04:24,660
以及你应该在这里看到的

92
00:04:24,660 --> 00:04:27,960
是你得到三个 console.log 消息

93
00:04:27,960 --> 00:04:30,280
因为我们这里有三个console.logs。

94
00:04:30,280 --> 00:04:34,330
第一个，目标本质上就是对象

95
00:04:34,330 --> 00:04:36,310
被包裹在这里。

96
00:04:36,310 --> 00:04:38,930
那只是你被包裹的对象。

97
00:04:38,930 --> 00:04:41,590
第二个，钥匙，

98
00:04:41,590 --> 00:04:46,350
是您刚刚为其设置新值的属性。

99
00:04:46,350 --> 00:04:48,800
第三个，价值，

100
00:04:48,800 --> 00:04:50,850
是设置的值。

101
00:04:50,850 --> 00:04:52,370
这希望能告诉你

102
00:04:52,370 --> 00:04:54,140
处理程序做什么。

103
00:04:54,140 --> 00:04:57,740
有了它，我们可以定义一个setter函数，

104
00:04:57,740 --> 00:05:02,720
每当设置属性时触发

105
00:05:02,720 --> 00:05:05,520
到此代理的新值

106
00:05:05,520 --> 00:05:08,640
然后我们可以找出是哪个属性，

107
00:05:08,640 --> 00:05:10,350
新值是什么

108
00:05:10,350 --> 00:05:12,943
以及我们包装了哪个原始对象。

109
00:05:14,180 --> 00:05:19,180
如果我们在这里有另一个属性，我们就可以使用它。

110
00:05:19,310 --> 00:05:21,120
比方说一个longMessage，

111
00:05:21,120 --> 00:05:23,663
最初是你好！世界！

112
00:05:24,640 --> 00:05:27,880
但我们要确保 longMessage 发生变化

113
00:05:27,880 --> 00:05:29,630
如果消息改变。

114
00:05:29,630 --> 00:05:31,453
假设这是我们的目标。

115
00:05:32,780 --> 00:05:34,680
现在，通过使用代理，

116
00:05:34,680 --> 00:05:39,060
并使用所谓的设置陷阱设置这样的处理程序，

117
00:05:39,060 --> 00:05:40,630
我们可以实现这一点。

118
00:05:40,630 --> 00:05:43,930
我们可以检查我们正在设置的密钥

119
00:05:43,930 --> 00:05:48,930
是消息，所以如果我们设置消息属性，

120
00:05:50,460 --> 00:05:52,250
如果我们这样做，

121
00:05:52,250 --> 00:05:53,780
我们要设置

122
00:05:56,110 --> 00:05:57,970
target.longMessage

123
00:06:00,350 --> 00:06:05,350
等于我们为消息分配的新值，加上 World！

124
00:06:07,930 --> 00:06:09,800
此后，我们也想确保

125
00:06:09,800 --> 00:06:12,130
消息属性本身已设置，

126
00:06:12,130 --> 00:06:15,793
所以我们将 target.message 设置为 value。

127
00:06:17,200 --> 00:06:19,680
现在可以看到有趣的事情了

128
00:06:19,680 --> 00:06:24,460
如果我们此后在这里 console.log proxy.longMessage

129
00:06:24,460 --> 00:06:27,970
在将消息设置为 Hello 之后的最后

130
00:06:27,970 --> 00:06:29,760
带有多个感叹号

131
00:06:29,760 --> 00:06:32,940
并在此处更新我们的处理程序之后。

132
00:06:32,940 --> 00:06:34,160
如果我们现在重新加载，

133
00:06:34,160 --> 00:06:38,060
我们从第 40 行看到，

134
00:06:38,060 --> 00:06:39,720
我们正在输出longMessage，

135
00:06:39,720 --> 00:06:43,899
现在拿起所有这些额外的感叹号。

136
00:06:43,899 --> 00:06:47,610
所以 longMessage 是在我们设置消息时更新的。

137
00:06:47,610 --> 00:06:51,100
所以在这里我们建立了自己的反应系统

138
00:06:51,100 --> 00:06:53,210
用于跟踪一个属性

139
00:06:53,210 --> 00:06:55,600
并更新另一个属性

140
00:06:55,600 --> 00:07:00,430
当那个属性，这里的 message 属性发生变化时。

141
00:07:00,430 --> 00:07:03,040
简而言之，当然，

142
00:07:03,040 --> 00:07:05,240
通过一些简化，

143
00:07:05,240 --> 00:07:08,421
这就是 Vue 在幕后所做的。

144
00:07:08,421 --> 00:07:12,410
它保持着在此处查看所有数据属性

145
00:07:12,410 --> 00:07:15,870
每当这样的属性发生变化时，

146
00:07:15,870 --> 00:07:18,770
它会更新您的应用程序的一部分

147
00:07:18,770 --> 00:07:20,720
使用该属性的位置。

148
00:07:20,720 --> 00:07:24,400
例如，它知道它需要更新这一段

149
00:07:24,400 --> 00:07:26,870
您在哪里使用消息。

150
00:07:26,870 --> 00:07:31,080
它通过用代理包装你的属性来做到这一点

151
00:07:31,080 --> 00:07:34,140
这样它就有机会发现

152
00:07:34,140 --> 00:07:36,436
当您设置新值时。

153
00:07:36,436 --> 00:07:38,930
这就是 Vue 的工作原理。

154
00:07:38,930 --> 00:07:42,020
当然，它有一种更复杂的方式

155
00:07:42,020 --> 00:07:44,660
这样做比我在那里。

156
00:07:44,660 --> 00:07:47,590
当然，它也有计算属性

157
00:07:47,590 --> 00:07:51,760
和当属性更改时触发的观察者。

158
00:07:51,760 --> 00:07:55,200
但这只是简而言之的方法，

159
00:07:55,200 --> 00:07:57,740
希望能给你一个想法

160
00:07:57,740 --> 00:08:00,250
Vue 如何在幕后工作

161
00:08:00,250 --> 00:08:03,220
所以 Vue 添加的这个魔法

162
00:08:03,220 --> 00:08:07,130
神奇的是少了一点魔力

163
00:08:07,130 --> 00:08:08,513
以积极的方式。