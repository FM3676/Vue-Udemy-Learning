1
00:00:01,500 --> 00:00:03,140
现在我们不仅有

2
00:00:03,140 --> 00:00:05,650
不过这个全球卫士。

3
00:00:05,650 --> 00:00:08,773
这里的 beforeEach 函数将运行

4
00:00:08,773 --> 00:00:11,840
在每个导航动作上，

5
00:00:11,840 --> 00:00:14,507
无论使用哪条路线，

6
00:00:14,507 --> 00:00:18,170
无论我们从哪条路线去另一条路线，

7
00:00:18,170 --> 00:00:20,127
这将始终运行。

8
00:00:20,127 --> 00:00:22,812
有时这是你需要的，有时不是，

9
00:00:22,812 --> 00:00:26,645
有时您只想保护个别路线。

10
00:00:26,645 --> 00:00:28,070
你当然可以这样做，

11
00:00:28,070 --> 00:00:30,490
如果在这里检查，您可以在此处检查您的

12
00:00:30,490 --> 00:00:31,711
并从路线对象，

13
00:00:31,711 --> 00:00:35,229
还可以根据不同的路线运行不同的逻辑。

14
00:00:35,229 --> 00:00:39,610
但是你也可以设置 beforeEach 导航守卫

15
00:00:39,610 --> 00:00:41,420
在单条路线上。

16
00:00:41,420 --> 00:00:43,970
例如，在用户上，让我们说。

17
00:00:43,970 --> 00:00:47,630
为此，您只需转到您的用户路线冲突，

18
00:00:47,630 --> 00:00:51,161
在这里你可以添加 beforeEnter，而不是 beforeEach，

19
00:00:51,161 --> 00:00:54,833
因为现在它在技术上只是一条路线。

20
00:00:54,833 --> 00:00:57,496
BeforeEnter 也是这里的一种方法。

21
00:00:57,496 --> 00:01:02,233
就像 beforeEach 一样，它到达、从和下一个。

22
00:01:03,067 --> 00:01:08,040
所以我在这里 console.log('users beforeEnter')

23
00:01:09,270 --> 00:01:12,792
也许还有 console.log(to, from) 是你想要的

24
00:01:12,792 --> 00:01:15,157
然后调用next确认

25
00:01:15,157 --> 00:01:18,090
或者做任何你想做的事情。

26
00:01:18,090 --> 00:01:20,239
Next 就像我解释的那样工作

27
00:01:20,239 --> 00:01:23,443
在 Global beforeEach 导航守卫上。

28
00:01:24,416 --> 00:01:28,310
在这里，我只是向用户确认每个导航。

29
00:01:28,310 --> 00:01:32,938
现在每当我们访问用户时都会调用它。

30
00:01:32,938 --> 00:01:35,803
因此，如果我保存并重新加载。

31
00:01:37,660 --> 00:01:40,979
如果我去用户那里，我们会看到 Global beforeEach，

32
00:01:40,979 --> 00:01:42,933
因为那仍然执行。

33
00:01:42,933 --> 00:01:45,763
毕竟它为每个导航动作执行。

34
00:01:45,763 --> 00:01:48,066
但是我们也看到用户之前进入

35
00:01:48,066 --> 00:01:51,510
然后是该页面的 to 和 from 的输出。

36
00:01:51,510 --> 00:01:53,663
当然，是指向用户页面，

37
00:01:53,663 --> 00:01:56,613
因为 beforeEnter 钩子已注册

38
00:01:56,613 --> 00:01:58,293
对于用户页面。

39
00:01:59,820 --> 00:02:01,414
现在，如果你不想注册

40
00:02:01,414 --> 00:02:05,730
这在路线级别或您的路线冲突中，

41
00:02:05,730 --> 00:02:07,191
你也可以添加一个新的钩子，

42
00:02:07,191 --> 00:02:09,910
组件内部的新方法。

43
00:02:09,910 --> 00:02:12,840
假设在用户列表组件中。

44
00:02:12,840 --> 00:02:15,380
在您的组件冲突对象中，

45
00:02:15,380 --> 00:02:18,497
您可以添加所有这些视图生命周期方法，

46
00:02:18,497 --> 00:02:22,553
喜欢创建或安装，您还可以添加

47
00:02:22,553 --> 00:02:26,246
beforeRouteEnter 方法。

48
00:02:26,246 --> 00:02:28,697
如果您使用我们所做的视图路由器，

49
00:02:28,697 --> 00:02:31,915
这将在导航之前调用

50
00:02:31,915 --> 00:02:35,108
对此组件进行了确认。

51
00:02:35,108 --> 00:02:40,108
再一次，你到达，从和下一个，

52
00:02:40,270 --> 00:02:42,400
因此我们可以做他以前做过的事。

53
00:02:42,400 --> 00:02:45,207
我们可以 console.log('usersList Cmp beforeRouteEnter')。

54
00:02:50,857 --> 00:02:54,759
然后我们当然可以 console.log(to, from)

55
00:02:54,759 --> 00:02:58,463
我们可以调用 next 或运行我们想要运行的任何逻辑

56
00:02:58,463 --> 00:03:03,463
确认或拒绝导航到下一个或重定向用户。

57
00:03:05,685 --> 00:03:08,860
有了这个，如果我去 Teams，

58
00:03:08,860 --> 00:03:11,534
重新加载，清除控制台并转到用户，

59
00:03:11,534 --> 00:03:14,705
我们看到 Global beforeEach 然后往返，

60
00:03:14,705 --> 00:03:17,473
users beforeEnter 然后往返，

61
00:03:17,473 --> 00:03:21,020
然后是UsersList Cmp beforeRouteEnter。

62
00:03:21,020 --> 00:03:21,853
这就是顺序

63
00:03:21,853 --> 00:03:24,603
这些导航守卫在其中执行。

64
00:03:24,603 --> 00:03:29,056
全局总是在前，然后是路由冲突级别

65
00:03:29,056 --> 00:03:31,223
然后是组件级别。

66
00:03:33,100 --> 00:03:37,036
所有这些钩子都在路线确认之前运行，

67
00:03:37,036 --> 00:03:40,220
这就是为什么你可以d 必须打电话给下一个

68
00:03:40,220 --> 00:03:42,950
手动确认或拒绝

69
00:03:42,950 --> 00:03:45,373
或将用户重定向到其他地方。

70
00:03:46,570 --> 00:03:50,501
我们还有另外两个与加载组件相关的守卫。

71
00:03:50,501 --> 00:03:53,277
一个是路由更新前的守卫，

72
00:03:53,277 --> 00:03:56,482
您直接在组件内部调用它。

73
00:03:56,482 --> 00:03:59,957
准确地说，在被重复使用的组件内部，

74
00:03:59,957 --> 00:04:03,120
在我们的例子中，这将是团队成员的组成部分。

75
00:04:03,120 --> 00:04:06,293
这里我们得到了参数，团队ID参数，

76
00:04:06,293 --> 00:04:10,068
我们绝对有可能在页面上

77
00:04:10,068 --> 00:04:14,059
一个团队，我们加载另一个团队成员页面。

78
00:04:14,059 --> 00:04:17,779
然后这个团队成员页面永远不会离开屏幕

79
00:04:17,779 --> 00:04:20,430
正如您所了解的，因此被重用。

80
00:04:20,430 --> 00:04:24,629
在这种情况下，视图路由器会调用另一个不错的方法

81
00:04:24,629 --> 00:04:26,880
在组件冲突对象中。

82
00:04:26,880 --> 00:04:29,178
也许这里旁边创建，

83
00:04:29,178 --> 00:04:33,889
在那里你可以添加 beforeRouteUpdate 方法

84
00:04:33,889 --> 00:04:38,683
并且视图将在此组件时调用此方法

85
00:04:38,683 --> 00:04:43,116
即将被新数据重用，

86
00:04:43,116 --> 00:04:44,802
因为路线变了。

87
00:04:44,802 --> 00:04:48,317
所以在这里我们也到达，从和下一个，

88
00:04:48,317 --> 00:04:53,223
然后你也可以拒绝或确认导航

89
00:04:53,223 --> 00:04:55,994
正如你所知道的，正如我之前解释的那样

90
00:04:55,994 --> 00:05:00,330
在 Global beforeEach 钩子上，这里也是一样的。

91
00:05:00,330 --> 00:05:01,927
当然除此之外，

92
00:05:01,927 --> 00:05:06,927
您可以使用往返，例如，

93
00:05:08,281 --> 00:05:13,281
根据新的团队 ID 参数调用 loadTeamMembers，

94
00:05:15,648 --> 00:05:20,648
你上的，被导航到路由对象。

95
00:05:21,176 --> 00:05:24,360
当然，现在我们已经有了逻辑

96
00:05:24,360 --> 00:05:27,105
处理更改的团队 ID 路由参数

97
00:05:27,105 --> 00:05:30,732
在这个组件中，所以我们不需要 beforeRouteUpdate

98
00:05:30,732 --> 00:05:33,558
为此，但使用 beforeRouteUpdate

99
00:05:33,558 --> 00:05:36,243
将是观看的替代品

100
00:05:36,243 --> 00:05:38,441
例如，团队 ID 道具。

101
00:05:38,441 --> 00:05:40,850
当然，有了那个钩子，

102
00:05:40,850 --> 00:05:45,720
我们再次绑定此组件以与路由一起使用。

103
00:05:45,720 --> 00:05:48,057
我们使用道具而不是路由参数

104
00:05:48,057 --> 00:05:50,650
使这个组件更加灵活。

105
00:05:50,650 --> 00:05:52,018
当我们使用这个替代方案时，

106
00:05:52,018 --> 00:05:54,220
我们会降低它的灵活性，

107
00:05:54,220 --> 00:05:57,168
因为只有在加载此组件时才会调用它

108
00:05:57,168 --> 00:06:00,871
并通过路由重新加载。

109
00:06:00,871 --> 00:06:03,941
但现在这将是一个替代方案

110
00:06:03,941 --> 00:06:06,867
我们可以在这里 console.log('TeamMembers Cmp beforeRouteUpdate')

111
00:06:13,294 --> 00:06:17,530
和 console.log(to, from) 如果你愿意，

112
00:06:17,530 --> 00:06:19,697
然后保存一切。

113
00:06:19,697 --> 00:06:21,980
现在如果我去另一个团队，

114
00:06:21,980 --> 00:06:25,639
我们看到 beforeRouteUpdate 运行良好，

115
00:06:25,639 --> 00:06:28,671
然后我们在那里的逻辑运行，我们在这里不需要，

116
00:06:28,671 --> 00:06:32,554
但我当然想给你看这个钩子。

117
00:06:32,554 --> 00:06:34,360
不过，我要对此发表评论，

118
00:06:34,360 --> 00:06:36,617
因为我们已经在加载团队成员

119
00:06:36,617 --> 00:06:40,510
当团队 ID 发生变化时，我们不需要这样做两次。

120
00:06:40,510 --> 00:06:42,996
但那是另一个导航守卫

121
00:06:42,996 --> 00:06:45,796
或者你也可以调用它的另一个导航钩子，

122
00:06:45,796 --> 00:06:47,453
这是值得知道的。