1
00:00:02,330 --> 00:00:07,190
所以现在让我们用 JavaScript 构建一个完整的动画

2
00:00:07,190 --> 00:00:09,468
而不是 CSS。

3
00:00:09,468 --> 00:00:12,370
它将在本段中做到这一点。

4
00:00:12,370 --> 00:00:15,070
因此，我实际上会删除所有

5
00:00:15,070 --> 00:00:18,010
那些para dash类。

6
00:00:18,010 --> 00:00:19,980
我将在这里简单地删除它们

7
00:00:19,980 --> 00:00:22,990
这样我们就不再使用那些 CSS 类了

8
00:00:22,990 --> 00:00:25,510
来控制它是如何被动画化的。

9
00:00:25,510 --> 00:00:28,580
相反，我现在想为此使用 JavaScript。

10
00:00:28,580 --> 00:00:31,437
这也是支持的东西

11
00:00:31,437 --> 00:00:33,690
过渡组件。

12
00:00:33,690 --> 00:00:38,120
现在通常，您最常使用 CSS，

13
00:00:38,120 --> 00:00:41,960
但改用 JavaScript 会很有用

14
00:00:41,960 --> 00:00:44,460
例如，如果您想使用

15
00:00:44,460 --> 00:00:48,070
第三方基于 JavaScript 的动画库

16
00:00:48,070 --> 00:00:49,680
像绿袜。

17
00:00:49,680 --> 00:00:52,400
GreenSock 与 Vue 无关，

18
00:00:52,400 --> 00:00:56,610
但它是一个用于编排的强大 JavaScript 库

19
00:00:56,610 --> 00:01:01,610
以及构建动画，使用 JavaScript 制作复杂的动画。

20
00:01:01,610 --> 00:01:04,310
那将是一个用例

21
00:01:04,310 --> 00:01:05,540
你可能想建的地方

22
00:01:05,540 --> 00:01:07,820
使用 JavaScript 完成整个过渡，

23
00:01:07,820 --> 00:01:11,140
因为您可能想利用这样的库。

24
00:01:11,140 --> 00:01:14,580
但即使没有这样的库，你也可以使用 JavaScript

25
00:01:14,580 --> 00:01:17,110
例如，在此处为该段落设置动画。

26
00:01:17,110 --> 00:01:19,890
这正是我们现在要做的。

27
00:01:19,890 --> 00:01:22,390
为此，我们已经添加了所有这些钩子

28
00:01:22,390 --> 00:01:24,670
你将需要这些钩子。

29
00:01:24,670 --> 00:01:28,230
您将需要它们，因为构建动画

30
00:01:28,230 --> 00:01:32,640
JavaScript 需要这些钩子。

31
00:01:32,640 --> 00:01:35,850
因为在某种程度上，它们仍然会被称为

32
00:01:35,850 --> 00:01:38,460
即使你没有 CSS 代码。

33
00:01:38,460 --> 00:01:40,928
即使你没有 CSS 动画。

34
00:01:40,928 --> 00:01:45,500
例如，如果我在这里重新加载，请记住

35
00:01:45,500 --> 00:01:49,270
我删除了之前添加的 CSS 类。

36
00:01:49,270 --> 00:01:53,439
我们仍然看到 beforeEnter 和 afterEnter 被调用。

37
00:01:53,439 --> 00:01:56,230
我们没有实际的过渡。

38
00:01:56,230 --> 00:02:00,360
一切都是即时的，但那些钩子仍然被调用。

39
00:02:00,360 --> 00:02:02,940
所以过渡组件上的那些事件

40
00:02:02,940 --> 00:02:06,410
总是在添加被包裹的元素时发出

41
00:02:06,410 --> 00:02:08,229
或删除到 DOM。

42
00:02:08,229 --> 00:02:11,890
但是没有任何控制动画的 CSS 代码，

43
00:02:11,890 --> 00:02:14,970
他们只是在彼此之后立即执行。

44
00:02:14,970 --> 00:02:18,150
因为当然，没有什么可以等待的。

45
00:02:18,150 --> 00:02:21,640
但这是我们现在可以用 JavaScript 改变的东西。

46
00:02:21,640 --> 00:02:24,533
为此，在进入之前，我们可以设置我们的

47
00:02:24,533 --> 00:02:27,343
初始动画状态。

48
00:02:29,230 --> 00:02:32,740
例如，在这里，我们可以接触到这个元素，

49
00:02:32,740 --> 00:02:33,920
这是上的元素

50
00:02:33,920 --> 00:02:36,360
我们要执行动画。

51
00:02:36,360 --> 00:02:40,240
我们可以在这里设置一个样式。

52
00:02:40,240 --> 00:02:42,780
我们可以在这里设置样式属性

53
00:02:42,780 --> 00:02:46,720
并使其不透明度为零。

54
00:02:46,720 --> 00:02:50,890
这是一种以编程方式设置不透明度的方法

55
00:02:50,890 --> 00:02:53,930
这个元素最初为零。

56
00:02:53,930 --> 00:02:55,820
这是香草 JavaScript，

57
00:02:55,820 --> 00:02:58,420
我们也可以在 Vue 中使用它。

58
00:02:58,420 --> 00:03:00,340
现在这是我最初的风格。

59
00:03:00,340 --> 00:03:03,427
在输入中，我现在想将其更改为一个，

60
00:03:03,427 --> 00:03:07,822
但不是立即，而是在一定时间内。

61
00:03:07,822 --> 00:03:10,300
这就是我们可以建造的东西

62
00:03:10,300 --> 00:03:13,380
通过在这里调用 setInterval。

63
00:03:13,380 --> 00:03:17,160
SetInterval 是一个内置的 JavaScript 函数，

64
00:03:17,160 --> 00:03:21,253
这允许我们每隔几毫秒执行一次代码。

65
00:03:22,180 --> 00:03:25,940
这里的第二个参数是毫秒数

66
00:03:25,940 --> 00:03:29,030
我们想等到下一个代码执行。

67
00:03:29,030 --> 00:03:31,063
在这里我们可以使用 20。

68
00:03:31,910 --> 00:03:33,900
第一个参数是一个函数

69
00:03:33,900 --> 00:03:38,220
现在将每 20 毫秒执行一次。

70
00:03:38,220 --> 00:03:41,363
在这里我们可以逐渐改变不透明度。

71
00:03:42,960 --> 00:03:45,460
我们可以通过使用我们的元素来做到这一点

72
00:03:45,460 --> 00:03:47,370
并设置其不透明度，

73
00:03:47,370 --> 00:03:50,130
但现在不是硬编码值，

74
00:03:50,130 --> 00:03:53,000
但是动态派生的值。

75
00:03:53,000 --> 00:03:55,600
并根据

76
00:03:55,600 --> 00:03:58,290
我们已经完成的间隔数

77
00:03:58,290 --> 00:04:01,920
或者我们已经完成的函数执行次数，

78
00:04:01,920 --> 00:04:04,930
我们可以跟踪当前回合，你可以说。

79
00:04:04,930 --> 00:04:07,570
在此处添加一个名为 around 的小辅助变量。

80
00:04:07,570 --> 00:04:12,465
从一开始并将不透明度设置为等于回合时间

81
00:04:12,465 --> 00:04:14,620
0.1，例如。

82
00:04:14,620 --> 00:04:17,800
所以在第一轮中，我们将其设置为 10% 的不透明度。

83
00:04:17,800 --> 00:04:20,973
在下一轮中，我们将其设置为 20%。

84
00:04:23,720 --> 00:04:26,600
现在我们只需要增加回合

85
00:04:26,600 --> 00:04:29,550
每次调用每个时间间隔

86
00:04:29,550 --> 00:04:32,190
此函数由 setInterval 调用。

87
00:04:32,190 --> 00:04:34,290
我们需要一个退出条件

88
00:04:34,290 --> 00:04:39,290
并检查round是否大于10，

89
00:04:39,290 --> 00:04:42,990
此时我们已经达到了 100% 的不透明度。

90
00:04:42,990 --> 00:04:44,563
如果是这样的话，

91
00:04:45,410 --> 00:04:50,090
我想调用 clearInterval 并清除此间隔。

92
00:04:50,090 --> 00:04:53,134
我们可以通过存储间隔来做到这一点，

93
00:04:53,134 --> 00:04:56,950
或指向该间隔的唯一 ID，您可以说，

94
00:04:56,950 --> 00:05:01,163
在一个常量中并将其传递给 clearInterval。

95
00:05:03,220 --> 00:05:05,460
所以现在间隔将被清除，

96
00:05:05,460 --> 00:05:09,373
如果我们超过 10 轮将停止。

97
00:05:10,930 --> 00:05:14,040
现在我们应该随着时间的推移对其进行动画处理。

98
00:05:14,040 --> 00:05:16,750
但仅凭这一点，我们就会遇到一个小问题。

99
00:05:16,750 --> 00:05:18,330
我会这么说的。

100
00:05:18,330 --> 00:05:23,300
如果我重新加载，我们可以看到段落淡入，对吧？

101
00:05:23,300 --> 00:05:24,920
这是你可以看到的。

102
00:05:24,920 --> 00:05:27,110
如果它太快，你可以放慢它

103
00:05:27,110 --> 00:05:30,010
只增加 1%，比方说

104
00:05:30,010 --> 00:05:32,223
并等待 100 轮。

105
00:05:33,380 --> 00:05:35,800
现在我们将在最后等待两秒钟

106
00:05:35,800 --> 00:05:38,200
直到这完全可见。

107
00:05:38,200 --> 00:05:40,143
因此，如果您保存并重新加载。

108
00:05:40,143 --> 00:05:43,790
现在，这里慢慢淡出。

109
00:05:43,790 --> 00:05:46,390
但是你会在右边注意到一个问题。

110
00:05:46,390 --> 00:05:50,300
如果我重新加载，清除控制台并单击切换段落，

111
00:05:50,300 --> 00:05:53,860
它在两秒钟内消失，但 afterEnter

112
00:05:53,860 --> 00:05:56,220
实际上在开始时就被调用了。

113
00:05:56,220 --> 00:05:57,590
再看一遍。

114
00:05:57,590 --> 00:05:59,260
我点击切换段落

115
00:05:59,260 --> 00:06:01,970
并立即调用 afterEnter。

116
00:06:01,970 --> 00:06:04,340
这对你来说可能很重要，也可能无关紧要。

117
00:06:04,340 --> 00:06:06,370
也许这对你来说并不重要。

118
00:06:06,370 --> 00:06:08,720
也许你不在乎这个。

119
00:06:08,720 --> 00:06:11,380
但实际上你可以看出这个顺序是错误的；

120
00:06:11,380 --> 00:06:12,810
它被称为太早了。

121
00:06:12,810 --> 00:06:15,510
在某些情况下，这可能很重要。

122
00:06:15,510 --> 00:06:17,160
这不是一个错误。

123
00:06:17,160 --> 00:06:20,256
但相反 Vue 没有机会知道

124
00:06:20,256 --> 00:06:22,877
什么时候应该调用 afterEnter。

125
00:06:22,877 --> 00:06:24,500
对我们来说这是显而易见的。

126
00:06:24,500 --> 00:06:27,840
我的意思是，我们完成了输入，一旦我们结束

127
00:06:27,840 --> 00:06:29,730
使它成为这个if条件。

128
00:06:29,730 --> 00:06:33,240
但这是视图并不真正理解的东西。

129
00:06:33,240 --> 00:06:35,200
这太合乎逻辑了。

130
00:06:35,200 --> 00:06:38,810
它不会解析并尝试理解我们的代码

131
00:06:38,810 --> 00:06:41,585
以及我们编写该代码的原因。

132
00:06:41,585 --> 00:06:45,120
相反，我们必须在这里完成时告诉你。

133
00:06:45,120 --> 00:06:46,750
为此，输入，

134
00:06:46,750 --> 00:06:50,760
实际上自动接收第二个参数。

135
00:06:50,760 --> 00:06:55,470
这是一个 done 函数，你可以随时调用

136
00:06:55,470 --> 00:07:00,233
你想向 Vue 发出信号，表明你已经完成了这个钩子。

137
00:07:01,680 --> 00:07:02,950
你不需要调用它

138
00:07:02,950 --> 00:07:06,290
如果你有基于 CSS 的动画

139
00:07:06,290 --> 00:07:09,170
因为 Vue 能够读取持续时间

140
00:07:09,170 --> 00:07:11,120
在 CSS 代码中。

141
00:07:11,120 --> 00:07:14,980
但是如果你不使用 CSS，如果你有自己的逻辑

142
00:07:14,980 --> 00:07:17,840
并且持续时间只是简单地弥补

143
00:07:17,840 --> 00:07:21,020
通过增加轮次并检查此条件

144
00:07:21,020 --> 00:07:23,490
并且在这里有一定的间隔时间，

145
00:07:23,490 --> 00:07:25,960
那么你需要明确地调用完成

146
00:07:25,960 --> 00:07:28,400
完成后让 Vue 知道。

147
00:07:28,400 --> 00:07:31,800
所以在 clearInterval 之后，我们调用 done。

148
00:07:31,800 --> 00:07:34,660
我们将此 done 参数称为函数

149
00:07:34,660 --> 00:07:36,913
让您知道我们何时完成。

150
00:07:38,510 --> 00:07:39,865
如果我在这里重新加载。

151
00:07:39,865 --> 00:07:44,260
现在我们可以切换段落，你会看到 afterEnter

152
00:07:44,260 --> 00:07:47,460
现在实际上只在稍后的时间点调用

153
00:07:47,460 --> 00:07:50,141
一旦我们确实完成了。

154
00:07:50,141 --> 00:07:53,340
这就是您现在可以控制动画的方式

155
00:07:53,340 --> 00:07:55,398
使用 JavaScript。

156
00:07:55,398 --> 00:07:58,120
当然，我们不仅限于控制

157
00:07:58,120 --> 00:08:00,810
使用 JavaScript 输入动画。

158
00:08:00,810 --> 00:08:03,630
我们也可以为离开写类似的东西。

159
00:08:03,630 --> 00:08:07,560
并且绝对可以随意为

160
00:08:07,560 --> 00:08:10,810
这个进入休假案例的动画。

161
00:08:10,810 --> 00:08:13,710
所以基本上相反，从一到零。

162
00:08:13,710 --> 00:08:16,720
这是您暂停视频的快速暂停

163
00:08:16,720 --> 00:08:18,160
并自己尝试。

164
00:08:18,160 --> 00:08:19,960
而且经常会一起做。

165
00:08:22,560 --> 00:08:24,600
那你成功了吗？

166
00:08:24,600 --> 00:08:26,650
让我们现在尝试收集。

167
00:08:26,650 --> 00:08:30,720
为此请假，我基本上会使用

168
00:08:30,720 --> 00:08:33,570
与我在这里输入的逻辑相同。

169
00:08:33,570 --> 00:08:37,839
我将复制整个代码并将其带到离开。

170
00:08:37,839 --> 00:08:40,150
但我会在这里做相反的事情。

171
00:08:40,150 --> 00:08:42,490
我基本上会

172
00:08:42,490 --> 00:08:47,490
将我的不透明度设置为一减去这个计算，

173
00:08:48,006 --> 00:08:51,140
所以我们从一个开始，我减少它

174
00:08:52,200 --> 00:08:53,680
他们都在我们可以离开之后

175
00:08:53,680 --> 00:08:55,880
其余代码原样。

176
00:08:55,880 --> 00:08:59,260
不过，在离开之前，我当然也想订

177
00:08:59,260 --> 00:09:03,140
初始不透明度为 1，虽然这有点多余

178
00:09:03,140 --> 00:09:07,020
因为那是我们的最终状态和我们的初始状态

179
00:09:07,020 --> 00:09:09,970
无论如何渲染和附加的元素。

180
00:09:09,970 --> 00:09:12,890
尽管如此，我们可以在这里设置它以非常清楚

181
00:09:12,890 --> 00:09:15,390
这是我们的起始状态

182
00:09:15,390 --> 00:09:17,023
离开动画。

183
00:09:18,650 --> 00:09:22,460
当然，我们都需要在这里接受这个完成的论点

184
00:09:22,460 --> 00:09:25,140
在 leave 方法中，以便我们可以在这里调用它

185
00:09:25,140 --> 00:09:26,343
当我们完成时。

186
00:09:27,320 --> 00:09:28,900
现在，我们当然也可以，

187
00:09:28,900 --> 00:09:30,950
在这里以不同的时间工作，

188
00:09:30,950 --> 00:09:33,500
如果我们愿意，可以进行不同数量的回合。

189
00:09:33,500 --> 00:09:35,750
但我会保持原样。

190
00:09:35,750 --> 00:09:37,970
有了这个，如果我重新加载，

191
00:09:37,970 --> 00:09:41,860
我可以切换段落以对其进行动画处理。

192
00:09:41,860 --> 00:09:45,233
然后我也可以制作动画。

193
00:09:47,170 --> 00:09:51,450
这就是您可以使用 JavaScript 控制动画的方式。

194
00:09:51,450 --> 00:09:54,550
现在，顺便说一句，如果这是动画

195
00:09:54,550 --> 00:09:57,370
然后我点击切换段落，

196
00:09:57,370 --> 00:10:01,770
再次，这会自动取消并反转它。

197
00:10:01,770 --> 00:10:05,113
但是，您也会看到它有点闪烁。

198
00:10:06,340 --> 00:10:08,630
它在闪烁，因为最后

199
00:10:08,630 --> 00:10:11,568
它同时播放两个动画。

200
00:10:11,568 --> 00:10:15,810
如果我们取消第一个只有我的动画回答

201
00:10:15,810 --> 00:10:17,930
离开动画开始之前

202
00:10:17,930 --> 00:10:21,640
进入动画完成或相反。

203
00:10:21,640 --> 00:10:24,310
那么两个动画同时播放

204
00:10:25,210 --> 00:10:27,773
导致您在此处看到的闪烁。

205
00:10:28,650 --> 00:10:31,103
这也是我们可以防止的。

206
00:10:32,690 --> 00:10:36,927
因为还有另一个有用的事件是由

207
00:10:36,927 --> 00:10:38,760
过渡组件。

208
00:10:38,760 --> 00:10:43,680
这就是 enter dash 取消事件

209
00:10:43,680 --> 00:10:48,066
和休假取消事件。

210
00:10:48,066 --> 00:10:51,590
在这里我们可以执行随时调用的方法

211
00:10:51,590 --> 00:10:54,290
动画被取消。

212
00:10:54,290 --> 00:10:56,640
顺便说一句，这些事件总是被发出

213
00:10:56,640 --> 00:10:59,580
当它被取消时，无论您是否正在编写逻辑

214
00:10:59,580 --> 00:11:01,910
使用 JavaScript，就像我们在这里做的那样。

215
00:11:01,910 --> 00:11:04,740
或者，如果您将像我们以前一样使用 CSS。

216
00:11:04,740 --> 00:11:07,540
每当一个过渡没有完成时，

217
00:11:07,540 --> 00:11:10,040
当你开始一个新的过渡时，

218
00:11:10,040 --> 00:11:13,530
将发出相应的取消事件。

219
00:11:13,530 --> 00:11:17,960
所以这里我们可以有一个 enterCanceled 方法

220
00:11:17,960 --> 00:11:22,460
以及应该调用的 leaveCanceled 方法。

221
00:11:22,460 --> 00:11:25,650
现在让我们添加这两个方法。

222
00:11:25,650 --> 00:11:28,730
输入取消

223
00:11:29,710 --> 00:11:30,610
并离开已取消。

224
00:11:32,620 --> 00:11:34,550
当然在这里我们也可以登录

225
00:11:34,550 --> 00:11:36,040
东西到控制台。

226
00:11:36,040 --> 00:11:39,090
我们也在这里得到了元素，我们可以改变它。

227
00:11:39,090 --> 00:11:41,660
但我想在这里做一件重要的事情。

228
00:11:41,660 --> 00:11:44,060
如果进入动画被取消，

229
00:11:44,060 --> 00:11:47,860
我想在这里取消我的输入间隔，

230
00:11:47,860 --> 00:11:51,100
这个间隔，就在它完成之前。

231
00:11:51,100 --> 00:11:54,85​​0
这样如果回合数达到 100 就不会被清除

232
00:11:54,85​​0 --> 00:11:59,150
但如果 enterCanceled 被触发，我也会清除它。

233
00:11:59,150 --> 00:12:01,910
使进入动画立即取消

234
00:12:01,910 --> 00:12:03,743
当叶子动画开始时。

235
00:12:04,660 --> 00:12:07,930
我想在 leaveCanceled 中做同样的事情。

236
00:12:07,930 --> 00:12:12,030
问题是我们将区间存储在常量中，

237
00:12:12,030 --> 00:12:16,160
这是 enter 和 leave 方法的一部分。

238
00:12:16,160 --> 00:12:18,690
所以这些常量只可用

239
00:12:18,690 --> 00:12:21,730
在这些方法中并且不可用

240
00:12:21,730 --> 00:12:23,823
进入和离开的内部取消。

241
00:12:25,510 --> 00:12:27,500
但解决方案很简单。

242
00:12:27,500 --> 00:12:31,184
这些是方法属性中的常规方法，对吗？

243
00:12:31,184 --> 00:12:33,920
所以，最后，我们可以只使用 data 属性

244
00:12:33,920 --> 00:12:35,790
存储这些间隔。

245
00:12:35,790 --> 00:12:40,120
我们可以在这里有我们的 enterInterval，

246
00:12:40,120 --> 00:12:41,510
最初为空。

247
00:12:41,510 --> 00:12:45,214
还有我们的 leaveInterval，最初为 null。

248
00:12:45,214 --> 00:12:49,080
现在我们在这里存储我们创建的间隔

249
00:12:49,080 --> 00:12:50,490
在 Enter 方法中

250
00:12:51,530 --> 00:12:54,165
在这个进入区间。

251
00:12:54,165 --> 00:12:58,529
我们在这里清除了这个 enterInterval

252
00:12:58,529 --> 00:13:01,000
我们在 leave 方法中做同样的事情。

253
00:13:01,000 --> 00:13:05,110
我们将间隔存储在这个 leaveInterval 中。

254
00:13:05,966 --> 00:13:09,700
我们取消了这个 leaveInterval。

255
00:13:12,210 --> 00:13:14,150
我们会在这里遇到一个小问题

256
00:13:14,150 --> 00:13:17,460
因为在这里我们正在访问这个 leaveInterval

257
00:13:17,460 --> 00:13:20,920
而这个 enterInterval 在嵌套函数内部。

258
00:13:20,920 --> 00:13:25,650
不幸的是，这个关键字不会指代

259
00:13:25,650 --> 00:13:28,520
与 Vue 应用程序对象相同

260
00:13:28,520 --> 00:13:31,533
就像它在这个嵌套函数之外所做的那样。

261
00:13:32,530 --> 00:13:36,330
解决方法很简单，我们使用箭头函数。

262
00:13:36,330 --> 00:13:39,540
这个关键字没有被覆盖

263
00:13:39,540 --> 00:13:41,890
因此将保留其上下文。

264
00:13:41,890 --> 00:13:45,000
因此，请确保在两个 setInterval 调用中

265
00:13:45,000 --> 00:13:47,033
您使用箭头功能。

266
00:13:48,048 --> 00:13:52,150
有了这个，我们现在可以使用 leave 和 enter interval

267
00:13:52,150 --> 00:13:56,020
那些新的数据属性，也在被取消的方法中。

268
00:13:56,020 --> 00:14:00,751
我们可以为此调用 clearInterval

269
00:14:00,751 --> 00:14:02,910
进入间隔。

270
00:14:02,910 --> 00:14:07,613
并在leaveCanceled，clearInterval上

271
00:14:07,613 --> 00:14:08,780
离开间隔。

272
00:14:12,060 --> 00:14:13,483
如果我们保存这个，

273
00:14:14,390 --> 00:14:15,610
是的，我的设置抱怨

274
00:14:15,610 --> 00:14:17,970
我从不使用 L 属性。

275
00:14:17,970 --> 00:14:21,610
因此，为了完整起见，我将在此处记录。

276
00:14:21,610 --> 00:14:24,640
或者，如果您不需要它，您可以省略它。

277
00:14:24,640 --> 00:14:26,970
但我会把它留在这里以便清楚

278
00:14:26,970 --> 00:14:28,650
我们会得到它。

279
00:14:28,650 --> 00:14:32,080
在此处记录，保存，现在保存的所有内容。

280
00:14:32,080 --> 00:14:35,358
现在，如果我单击切换段落并再次单击，

281
00:14:35,358 --> 00:14:37,890
现在我们没有闪烁

282
00:14:37,890 --> 00:14:39,900
因为现在我们要取消这个。

283
00:14:39,900 --> 00:14:43,660
我们正在清除间隔，我们要回去了

284
00:14:43,660 --> 00:14:45,233
因此删除它。

285
00:14:48,170 --> 00:14:52,110
所以现在进入和离开已取消

286
00:14:52,110 --> 00:14:55,433
这些事件是否存在以及你可以用它们做什么。