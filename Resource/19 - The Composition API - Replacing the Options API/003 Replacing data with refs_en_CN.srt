1
00:00:01,734 --> 00:00:06,110
因此，现在让我们深入了解 Composition API。

2
00:00:06,110 --> 00:00:08,970
我已经提到我们在谈论数据，

3
00:00:08,970 --> 00:00:11,290
方法，计算和观察，

4
00:00:11,290 --> 00:00:13,850
我们正在谈论这四个选项，

5
00:00:13,850 --> 00:00:15,670
来自选项 API，

6
00:00:15,670 --> 00:00:18,540
现在将以不同的方式处理

7
00:00:18,540 --> 00:00:20,370
在组合 API 中。

8
00:00:20,370 --> 00:00:22,880
这四个选项到底是，

9
00:00:22,880 --> 00:00:25,450
将被替换为代码

10
00:00:25,450 --> 00:00:29,000
我们将写入新的设置选项。

11
00:00:29,000 --> 00:00:32,840
一个新的设置方法，我们可以添加到我们的对象

12
00:00:32,840 --> 00:00:36,403
我们的组件或 Vue 应用程序配置对象。

13
00:00:37,430 --> 00:00:38,630
另一方面，

14
00:00:38,630 --> 00:00:43,110
这意味着我们还了解了所有其他选项。

15
00:00:43,110 --> 00:00:46,370
道具发射，组件，

16
00:00:46,370 --> 00:00:50,140
那些仍然不受组合 API 的影响。

17
00:00:50,140 --> 00:00:52,350
所以在那里，没有任何改变

18
00:00:52,350 --> 00:00:56,260
您对这些选项的了解不会改变。

19
00:00:56,260 --> 00:00:58,710
唯一会改变的其他部分，

20
00:00:58,710 --> 00:01:00,470
不在这张幻灯片上，

21
00:01:00,470 --> 00:01:02,550
将是生命周期方法，

22
00:01:02,550 --> 00:01:05,379
但我稍后再谈。

23
00:01:05,379 --> 00:01:07,030
现在让我们从数据开始，

24
00:01:07,030 --> 00:01:09,250
让我们看看我们如何替换数据

25
00:01:09,250 --> 00:01:12,953
使用 Composition API 和此设置方法。

26
00:01:14,160 --> 00:01:17,370
对于这个附件，你会发现一个非常简单的项目。

27
00:01:17,370 --> 00:01:20,690
目前它只有一个应用程序，一个 Vue 文件。

28
00:01:20,690 --> 00:01:22,880
这也很简单。

29
00:01:22,880 --> 00:01:24,750
我只是在这里放一个用户名，

30
00:01:24,750 --> 00:01:29,560
目前已硬编码到我的数据选项中。

31
00:01:29,560 --> 00:01:31,510
但这仍然是选择的日期，

32
00:01:31,510 --> 00:01:34,360
所以我们还没有使用 Composition API。

33
00:01:34,360 --> 00:01:35,650
这里有一些造型

34
00:01:35,650 --> 00:01:37,850
如果您安装所有依赖项

35
00:01:37,850 --> 00:01:42,090
然后用 npm run serve 启动你的开发服务器，

36
00:01:42,090 --> 00:01:45,190
你在屏幕上看到这个。

37
00:01:45,190 --> 00:01:47,530
现在让我们看看等效的

38
00:01:47,530 --> 00:01:51,820
如果我们使用组合 API，则此数据选项将是

39
00:01:51,820 --> 00:01:55,110
因此，我将注释掉数据，而不是，

40
00:01:55,110 --> 00:01:59,980
我要做的第一件事就是添加这个设置方法。

41
00:01:59,980 --> 00:02:04,250
这是自 Vue 版本 3 以来我们可以添加的新方法，

42
00:02:04,250 --> 00:02:07,790
在我们的组件配置对象中。

43
00:02:07,790 --> 00:02:09,699
再说一次，如果我们有类似的东西

44
00:02:09,699 --> 00:02:13,550
在 components 选项中注册的本地组件，

45
00:02:13,550 --> 00:02:17,960
或者如果我们在这里有道具，那将保持不变，

46
00:02:17,960 --> 00:02:20,140
那会留在这里。

47
00:02:20,140 --> 00:02:21,740
但是我们现在添加了设置

48
00:02:21,740 --> 00:02:25,120
现在的目标是替换我们在这里管理的数据，

49
00:02:25,120 --> 00:02:28,600
所以用户名，有了新的东西，

50
00:02:28,600 --> 00:02:31,610
这样我们仍然可以在模板中输出它。

51
00:02:31,610 --> 00:02:36,060
我们得到了 Vue 提供的两个新特性，

52
00:02:36,060 --> 00:02:38,480
这有助于我们管理数据。

53
00:02:38,480 --> 00:02:41,830
我们需要从 Vue 中导入它们，

54
00:02:41,830 --> 00:02:43,860
所以我们需要添加import语句

55
00:02:43,860 --> 00:02:47,010
从 Vue 导入一些东西

56
00:02:47,010 --> 00:02:50,600
并且这里的东西会放在花括号之间

57
00:02:50,600 --> 00:02:52,250
是参考。

58
00:02:52,250 --> 00:02:53,840
现在，这是进口罪税，

59
00:02:53,840 --> 00:02:57,370
它导入了 Vue 导出的许多东西之一

60
00:02:57,370 --> 00:02:59,710
这里正在导入参考。

61
00:02:59,710 --> 00:03:00,740
现在什么是参考？

62
00:03:00,740 --> 00:03:04,070
我们在课程的早些时候了解了 refs。

63
00:03:04,070 --> 00:03:06,070
暂时，让我们忽略这一点，

64
00:03:06,070 --> 00:03:09,550
ref 与我们对 refs 的了解略有相关

65
00:03:09,550 --> 00:03:10,660
在过去，

66
00:03:10,660 --> 00:03:12,880
但另一方面，它仍然是新事物。

67
00:03:12,880 --> 00:03:15,720
因此，到目前为止，让我们忽略有关 refs 的信息。

68
00:03:15,720 --> 00:03:17,453
这里的概念不同，

69
00:03:18,680 --> 00:03:22,750
因为e red 是我们现在可以调用的函数

70
00:03:22,750 --> 00:03:24,660
设置里面。

71
00:03:24,660 --> 00:03:28,210
并且 ref 创建了一个所谓的引用

72
00:03:28,210 --> 00:03:32,430
但现在不仅仅是对某些 DOM 元素的引用

73
00:03:32,430 --> 00:03:36,040
而是一个我们可以引用的值，

74
00:03:36,040 --> 00:03:39,750
例如，我们可以在模板中使用它。

75
00:03:39,750 --> 00:03:44,580
所以 ref 创造了一个价值，但不是任何一种价值。

76
00:03:44,580 --> 00:03:47,410
取而代之的是一个反应值，

77
00:03:47,410 --> 00:03:50,670
当我们改变它时，Vue 会在哪里找到它。

78
00:03:50,670 --> 00:03:53,200
Vue 可以在哪里观看

79
00:03:53,200 --> 00:03:57,290
然后 Vue 可以在哪里更新模板

80
00:03:57,290 --> 00:03:59,910
在 DOM 中，当该值更改时

81
00:03:59,910 --> 00:04:01,833
并且正在模板中使用。

82
00:04:03,190 --> 00:04:05,810
但是像这样的 ref 实际上什么也没做。

83
00:04:05,810 --> 00:04:08,130
正如我提到的，它创造了一个价值，

84
00:04:08,130 --> 00:04:12,110
所以我们应该将它存储在某个变量或常量中。

85
00:04:12,110 --> 00:04:14,778
我们不会在这里使用 this 关键字，

86
00:04:14,778 --> 00:04:18,310
因为虽然它在技术上是可用的，

87
00:04:18,310 --> 00:04:19,610
在设置方法中，

88
00:04:19,610 --> 00:04:22,420
因为这仍然是这个对象中的一个方法，

89
00:04:22,420 --> 00:04:24,450
这实际上是

90
00:04:24,450 --> 00:04:27,830
不引用 Vue 配置对象

91
00:04:27,830 --> 00:04:30,600
例如，就像在方法中所做的那样。

92
00:04:30,600 --> 00:04:35,600
因为 setup 是 Vue 很早就执行的方法

93
00:04:35,790 --> 00:04:38,930
在组件初始化过程中。

94
00:04:38,930 --> 00:04:40,540
在某个时间点，

95
00:04:40,540 --> 00:04:43,720
该组件尚未初始化的地方

96
00:04:43,720 --> 00:04:47,030
因此这实际上不会给我们访问权限

97
00:04:47,030 --> 00:04:49,290
我们习惯的所有事情。

98
00:04:49,290 --> 00:04:53,610
如果我们有任何道具，它不会让我们访问道具等等。

99
00:04:53,610 --> 00:04:56,390
所以我们这里在 setup 方法中不使用这个。

100
00:04:56,390 --> 00:04:59,890
而且我们不会将此值存储在属性中

101
00:04:59,890 --> 00:05:01,873
这个整体配置对象。

102
00:05:02,870 --> 00:05:04,590
相反，只是要存储它

103
00:05:04,590 --> 00:05:07,630
在普通的变量或常量中

104
00:05:07,630 --> 00:05:09,330
在这里和去一个常数

105
00:05:09,330 --> 00:05:11,310
我将其命名为 userName

106
00:05:12,350 --> 00:05:17,020
所以现在这里的 ref 东西存储在这个常量中。

107
00:05:17,020 --> 00:05:19,800
现在我说 ref 创建了一个反应值

108
00:05:19,800 --> 00:05:22,140
但这里的实际价值是多少？

109
00:05:22,140 --> 00:05:25,560
我们可能想要存储一个数字，或者在这种情况下是一个字符串，

110
00:05:25,560 --> 00:05:26,920
我们的名字。

111
00:05:26,920 --> 00:05:30,710
那么你可以传递你想要存储的实际值，

112
00:05:30,710 --> 00:05:33,490
作为我们对此 ref 函数的参数。

113
00:05:33,490 --> 00:05:35,860
所以在这里我会通过马克西米利安

114
00:05:36,960 --> 00:05:40,960
现在这会创建一个反应字符串，你可以说，

115
00:05:40,960 --> 00:05:43,210
在引擎盖下，它创建了一个对象。

116
00:05:43,210 --> 00:05:46,010
该字符串存储在该对象中

117
00:05:46,010 --> 00:05:48,240
Vue 会监视这个对象，

118
00:05:48,240 --> 00:05:51,410
这样每当我们分配一个新值时

119
00:05:51,410 --> 00:05:53,270
而不是那个原始字符串。

120
00:05:53,270 --> 00:05:58,120
Vue 会意识到这一点并能够更新 DOM。

121
00:05:58,120 --> 00:06:02,670
但是一步一步，目前这段代码根本行不通。

122
00:06:02,670 --> 00:06:04,900
如果我们尝试保存它，我们会得到一个错误。

123
00:06:04,900 --> 00:06:08,770
该 userName 已创建，但从未使用过。

124
00:06:08,770 --> 00:06:11,570
确实，我们有那个 userName 常量，

125
00:06:11,570 --> 00:06:14,140
但我们没有用它做任何事情。

126
00:06:14,140 --> 00:06:17,040
您可能认为我们在模板中使用它

127
00:06:17,040 --> 00:06:19,500
但实际上这不是它的工作原理。

128
00:06:19,500 --> 00:06:22,810
选项 API 就是这种情况

129
00:06:22,810 --> 00:06:25,600
您有权访问所有数据属性，

130
00:06:25,600 --> 00:06:28,580
您的计算属性和方法，

131
00:06:28,580 --> 00:06:30,433
在 DOM 中就是这样。

132
00:06:31,370 --> 00:06:35,010
某些常量并非如此

133
00:06:35,010 --> 00:06:37,070
你可能有你的设置方法。

134
00:06:37,070 --> 00:06:38,740
如果你在这里有一个常数，

135
00:06:38,740 --> 00:06:42,570
它在您的 DOM 中不可用，在您的模板中te。

136
00:06:42,570 --> 00:06:45,240
相反，您需要做一个额外的步骤。

137
00:06:45,240 --> 00:06:49,790
您需要返回您要公开的内容

138
00:06:49,790 --> 00:06:52,600
到这个组件的模板

139
00:06:52,600 --> 00:06:54,940
这个配置对象属于。

140
00:06:54,940 --> 00:06:58,500
而且你总是在这里返回一个对象。

141
00:06:58,500 --> 00:07:01,960
所以在设置中，你返回一个对象

142
00:07:01,960 --> 00:07:05,140
在这个对象中，我们将把所有的东西

143
00:07:05,140 --> 00:07:06,993
我们想暴露给模板。

144
00:07:07,990 --> 00:07:12,120
所以在这里我们要访问一个 userName 的东西

145
00:07:12,120 --> 00:07:14,820
因此在这个返回的对象中

146
00:07:14,820 --> 00:07:17,570
我们应该添加一个 userName 键

147
00:07:17,570 --> 00:07:20,630
以及我们想在那个键下存储的值，

148
00:07:20,630 --> 00:07:23,290
是存储在此常量中的值。

149
00:07:23,290 --> 00:07:24,910
这是所有的名字，用户名

150
00:07:24,910 --> 00:07:27,230
但我们可以在这里选择不同的名称。

151
00:07:27,230 --> 00:07:30,537
为避免混淆，我们不妨将这个 uName 命名为

152
00:07:30,537 --> 00:07:32,637
因此这里所有的名字都是uName。

153
00:07:33,620 --> 00:07:35,870
所以这里我指的是这个常数。

154
00:07:35,870 --> 00:07:37,800
在这里我命名这个用户名

155
00:07:37,800 --> 00:07:40,453
因为我正在模板中访问用户名。

156
00:07:41,340 --> 00:07:44,030
以及我在这个返回的对象中公开的内容

157
00:07:44,030 --> 00:07:47,040
现在在此模板中可用

158
00:07:47,040 --> 00:07:49,810
如果我现在保存并重新加载，

159
00:07:49,810 --> 00:07:54,253
一切正常，我们在我们的页面上看到了马克西米利安。

160
00:07:55,670 --> 00:07:58,210
这就是我们创造和存储价值的方式

161
00:07:58,210 --> 00:08:00,110
使用组合 API。

162
00:08:00,110 --> 00:08:02,060
我们使用这种 ref 方法。

163
00:08:02,060 --> 00:08:06,030
现在，实际上你甚至不需要 ref 方法，

164
00:08:06,030 --> 00:08:10,100
如果我删除它并在此处存储一个普通字符串。

165
00:08:10,100 --> 00:08:13,350
如果我保存它，我会收到一个错误，我正在导入 ref

166
00:08:13,350 --> 00:08:14,930
我没有使用它，

167
00:08:14,930 --> 00:08:17,270
所以让我们快速完成导入，

168
00:08:17,270 --> 00:08:20,940
但是如果我保存了它，那么所有的话。

169
00:08:20,940 --> 00:08:22,913
那么为什么我需要 ref 呢？

170
00:08:24,750 --> 00:08:27,450
好吧，因为我已经说过了，

171
00:08:27,450 --> 00:08:31,730
如果我们使用 ref 创建，将是一个反应值

172
00:08:31,730 --> 00:08:34,200
这就是我想在这里向你展示的下一件事。

173
00:08:34,200 --> 00:08:36,330
假设我们这里有一个计时器。

174
00:08:36,330 --> 00:08:39,570
我们使用设置超时，它内置在浏览器中

175
00:08:39,570 --> 00:08:43,830
两秒钟后，我们在这里执行一个函数。

176
00:08:43,830 --> 00:08:47,500
在这个函数中，我想分配一个新值

177
00:08:47,500 --> 00:08:49,253
到我的 uName 常量。

178
00:08:50,400 --> 00:08:52,420
现在这是我们不打算这样做的方法。

179
00:08:52,420 --> 00:08:57,120
我们不会说 uName 等于您的新值。

180
00:08:57,120 --> 00:09:00,500
一方面，这是不允许的，因为这是一个常数。

181
00:09:00,500 --> 00:09:02,690
当然我们可以把它变成一个变量

182
00:09:02,690 --> 00:09:04,800
现在我们可以分配一个新值，

183
00:09:04,800 --> 00:09:07,750
但现在我们将覆盖旧的 ref

184
00:09:07,750 --> 00:09:11,500
使用一个简单的新字符串，所以我们会丢失参考。

185
00:09:11,500 --> 00:09:12,600
你想要一个参考

186
00:09:12,600 --> 00:09:15,700
因为 ref 有一些内置机制

187
00:09:15,700 --> 00:09:19,050
让 Vue 知道该值的更改

188
00:09:19,050 --> 00:09:21,500
因为如果我们这样做，

189
00:09:21,500 --> 00:09:23,280
你会注意到如果我保存了这个

190
00:09:23,280 --> 00:09:25,940
我重新加载，两秒钟后，

191
00:09:25,940 --> 00:09:28,510
屏幕上什么也没有发生。

192
00:09:28,510 --> 00:09:30,190
我们总是在这里看到马克西米利安。

193
00:09:30,190 --> 00:09:34,370
Never Max，现在我确实为 uName 分配了一个新值

194
00:09:34,370 --> 00:09:35,680
两秒后，

195
00:09:35,680 --> 00:09:39,343
但是 Vue 从未使用过这个新值。

196
00:09:40,200 --> 00:09:42,310
setup 方法只运行一次，

197
00:09:42,310 --> 00:09:44,640
所以我们永远不会返回一个新对象

198
00:09:44,640 --> 00:09:47,480
使用模板的新值。

199
00:09:47,480 --> 00:09:49,650
这正是我们需要 ref 的原因

200
00:09:49,650 --> 00:09:50,970
这就是我们可以使用 const

201
00:09:50,970 --> 00:09:53,200
因为我永远不会分配新值

202
00:09:53,200 --> 00:09:54,880
像这样给uName。

203
00:09:54,880 -->00:09:58,720
相反，我们可以使用 uName 来保存这个 ref

204
00:09:58,720 --> 00:10:01,670
并充当价值属性。

205
00:10:01,670 --> 00:10:05,410
我提到了 ref 函数创建了一个对象

206
00:10:05,410 --> 00:10:09,570
在引擎盖下，这是一个具有 value 属性的对象。

207
00:10:09,570 --> 00:10:13,210
值，您在此处传递给 ref 函数。

208
00:10:13,210 --> 00:10:16,290
存储在该值属性下。

209
00:10:16,290 --> 00:10:18,560
您可以分配新值，

210
00:10:18,560 --> 00:10:21,990
在这个 uName 对象中排队这个值属性。

211
00:10:21,990 --> 00:10:24,310
例如，马克斯。

212
00:10:24,310 --> 00:10:28,080
如果你这样做了，那么 Vue 会选择它

213
00:10:28,080 --> 00:10:31,370
并将更新 DOM 和模板。

214
00:10:31,370 --> 00:10:35,020
您会在两秒钟后看到此更改为 Max

215
00:10:35,020 --> 00:10:36,540
这就是我们在这里使用 ref 的原因。

216
00:10:36,540 --> 00:10:41,160
这是一个反应值，我们可以在这里管理任何值。

217
00:10:41,160 --> 00:10:45,420
一根绳子，一个数字，一块金条，随便你。

218
00:10:45,420 --> 00:10:48,690
Vue 会观察它并接受变化

219
00:10:48,690 --> 00:10:52,033
像这里一样在 DOM 中反映它们。

220
00:10:53,150 --> 00:10:56,450
现在顺便说一下这里的模板。

221
00:10:56,450 --> 00:10:59,280
你不能在这里访问点值，

222
00:10:59,280 --> 00:11:02,960
因为 Vue 会自动深入到那个 value prop

223
00:11:02,960 --> 00:11:07,960
如果您在返回对象中公开 ref

224
00:11:07,990 --> 00:11:09,200
在设置方法中。

225
00:11:09,200 --> 00:11:11,470
所以这里 userName 指向一个 ref

226
00:11:11,470 --> 00:11:14,130
我们需要使用 value 属性，

227
00:11:14,130 --> 00:11:15,990
如果我们想设置一个新值。

228
00:11:15,990 --> 00:11:18,580
但是如果我们将 ref 传递给模板，

229
00:11:18,580 --> 00:11:21,840
Vue 会自动读取 value 属性，

230
00:11:21,840 --> 00:11:24,300
所以在模板中你不使用点值

231
00:11:24,300 --> 00:11:27,683
但只是整个 ref 和 Vue 将完成其余的工作。