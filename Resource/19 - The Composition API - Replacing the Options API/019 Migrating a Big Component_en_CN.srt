1
00:00:02,330 --> 00:00:04,410
作为下一个要迁移的组件，

2
00:00:04,410 --> 00:00:07,970
我将处理一个大的 UserList.vue。

3
00:00:07,970 --> 00:00:10,700
这个组件包含很多逻辑。

4
00:00:10,700 --> 00:00:13,540
这实际上是我使用的组件

5
00:00:13,540 --> 00:00:16,300
作为一个看到逻辑的例子

6
00:00:16,300 --> 00:00:19,170
分散在选项中。

7
00:00:19,170 --> 00:00:21,420
所以现在我们终于可以希望看到

8
00:00:21,420 --> 00:00:24,540
我们如何将逻辑保存在一个地方

9
00:00:24,540 --> 00:00:26,163
使用组合 API。

10
00:00:27,240 --> 00:00:29,170
所以在 UserList.vue 文件中，

11
00:00:29,170 --> 00:00:33,140
再次，我将从添加设置方法开始，

12
00:00:33,140 --> 00:00:34,960
我也想说清楚

13
00:00:34,960 --> 00:00:38,500
我们保持组件和道具不变。

14
00:00:38,500 --> 00:00:41,170
这些选项仍然存在，

15
00:00:41,170 --> 00:00:44,500
它们不会被 Composition API 取代。

16
00:00:44,500 --> 00:00:46,520
他们仍然像你学习的那样工作，

17
00:00:46,520 --> 00:00:48,730
我们仍然告诉 Vue 哪些本地组件

18
00:00:48,730 --> 00:00:50,300
我们想在这个组件中使用，

19
00:00:50,300 --> 00:00:52,660
我们仍然会通知 Vue 关于 props

20
00:00:52,660 --> 00:00:55,913
这个组件接收，所以它留在原处。

21
00:00:57,040 --> 00:01:00,470
但是，当然，我将在这里替换我的数据。

22
00:01:00,470 --> 00:01:03,870
所以我现在没有设置，而是得到了三个数据

23
00:01:03,870 --> 00:01:05,000
我想管理的，

24
00:01:05,000 --> 00:01:08,420
并且所有三个数据都应该是反应性的，

25
00:01:08,420 --> 00:01:10,240
他们可以改变，而 Vue 应该可以

26
00:01:10,240 --> 00:01:12,163
注意到这些变化。

27
00:01:13,100 --> 00:01:14,420
再一次，这取决于你，

28
00:01:14,420 --> 00:01:17,280
无论您想使用对象还是引用，

29
00:01:17,280 --> 00:01:20,680
或者也许将这些搜索的东西组合成一个对象

30
00:01:20,680 --> 00:01:24,293
并使用 ref 进行排序，完全取决于您。

31
00:01:25,290 --> 00:01:27,570
我会再去这里找裁判，

32
00:01:27,570 --> 00:01:31,220
因为我喜欢参考文献为我们提供的简单性。

33
00:01:31,220 --> 00:01:36,200
所以这里我将简单地从 Vue 中导入 ref 函数，

34
00:01:36,200 --> 00:01:40,230
然后在设置中，我得到了三个想要创建的参考

35
00:01:40,230 --> 00:01:42,690
我会保留我们的名字。

36
00:01:42,690 --> 00:01:46,350
所以输入的SearchTerm 是一个参考

37
00:01:46,350 --> 00:01:48,440
其中初始值为空字符串。

38
00:01:48,440 --> 00:01:52,600
activeSearchTerm 是一个参考

39
00:01:52,600 --> 00:01:54,010
最初是一个空字符串，

40
00:01:54,010 --> 00:01:56,440
或包含一个空字符串，

41
00:01:56,440 --> 00:02:01,440
并且排序是一个 ref，它最初将 null 作为一个值。

42
00:02:02,940 --> 00:02:05,540
所以现在这些是我们的三个数据，

43
00:02:05,540 --> 00:02:07,490
现在我会做一件事，

44
00:02:07,490 --> 00:02:10,130
这是我们无法使用 Options API 完成的，

45
00:02:10,130 --> 00:02:13,900
我将分割我定义数据的地方，

46
00:02:13,900 --> 00:02:17,820
因为我现在想把所有其他搜索相关的东西，

47
00:02:17,820 --> 00:02:22,820
函数等等，直接在这些参考下面

48
00:02:23,110 --> 00:02:27,140
并将所有与排序相关的逻辑放在此参考下方。

49
00:02:27,140 --> 00:02:30,450
所以我们首先有搜索逻辑，然后是排序逻辑，

50
00:02:30,450 --> 00:02:34,740
这样我们就没有逻辑分裂

51
00:02:34,740 --> 00:02:37,550
跨越不同的地方，所以现在我们可以保持

52
00:02:37,550 --> 00:02:39,953
属于在一起的东西，在一起。

53
00:02:42,100 --> 00:02:44,510
无论如何，我们可以再次摆脱数据，

54
00:02:44,510 --> 00:02:46,320
您可以删除它或将其注释掉。

55
00:02:46,320 --> 00:02:48,260
在这里，我暂时将其注释掉

56
00:02:48,260 --> 00:02:50,900
这样我们仍然可以看到我们来自哪里，

57
00:02:50,900 --> 00:02:52,760
以便我们稍后可以看到不同之处

58
00:02:52,760 --> 00:02:55,593
组合 API 和选项 API 之间。

59
00:02:56,510 --> 00:02:59,010
我们可以继续计算，

60
00:02:59,010 --> 00:03:01,550
在这里，我们得到了 availableUsers

61
00:03:01,550 --> 00:03:04,400
我到底在哪里检查我的 activeSearchTerm

62
00:03:04,400 --> 00:03:07,410
根据搜索词过滤用户

63
00:03:08,440 --> 00:03:11,440
displayUsers 是另一个计算属性，

64
00:03:11,440 --> 00:03:12,920
处理排序。

65
00:03:12,920 --> 00:03:15,430
所以这里我们有两种不同的逻辑，

66
00:03:15,430 --> 00:03:17,263
搜索和排序。

67
00:03:18,480 --> 00:03:20,740
无论如何，我们得到计算属性

68
00:03:20,740 --> 00:03:24,390
因此我们应该从 Vue 导入计算

69
00:03:24,390 --> 00:03:27,320
因为那是我们的 Composition API 等价物

70
00:03:27,320 --> 00:03:29,250
到计算选项。

71
00:03:29,250 --> 00:03:32,920
然后让我们从用于搜索的计算属性开始。

72
00:03:32,920 --> 00:03:34,770
所以我们可以在这里调用计算它，

73
00:03:34,770 --> 00:03:38,610
然后传入这样的函数，

74
00:03:38,610 --> 00:03:43,610
我现在想好好计算的地方，我的可用用户，

75
00:03:43,690 --> 00:03:45,440
我们可以复制逻辑

76
00:03:45,440 --> 00:03:50,440
从那里的计算属性，将其复制到这里，

77
00:03:50,760 --> 00:03:53,760
但现在当然不是这个 activeSearchTerm，

78
00:03:53,760 --> 00:03:58,410
但是 activeSearchTerm.value 因为 activeSearchTerm 是一个参考

79
00:03:58,410 --> 00:04:01,240
你了解到我们需要访问 value 属性

80
00:04:01,240 --> 00:04:02,483
读取值。

81
00:04:03,730 --> 00:04:05,970
它也不会是 this.users，

82
00:04:05,970 --> 00:04:09,320
但是，用户来自哪里？

83
00:04:09,320 --> 00:04:10,820
这里的用户是什么？

84
00:04:10,820 --> 00:04:14,390
this.Users，那是我们的道具，

85
00:04:14,390 --> 00:04:18,720
在 Options API 中，我们可以使用这个关键字来引用 props，

86
00:04:18,720 --> 00:04:22,063
这然后是道具名称和用户是道具。

87
00:04:23,000 --> 00:04:24,263
在你学习的设置方法中

88
00:04:24,263 --> 00:04:27,760
这个关键字是未定义的，所以这不起作用。

89
00:04:27,760 --> 00:04:29,863
我们如何才能访问那里的道具？

90
00:04:30,900 --> 00:04:33,310
好吧，你可能还记得设置方法

91
00:04:33,310 --> 00:04:35,870
获取两个参数，你可以接受

92
00:04:35,870 --> 00:04:38,460
哪个可以使用它总是让他们

93
00:04:38,460 --> 00:04:40,080
由 Vue 自动生成，

94
00:04:40,080 --> 00:04:43,160
在这里，第一个参数是帮助我们的参数。

95
00:04:43,160 --> 00:04:46,450
这是一个充满该组件接收到的道具的对象。

96
00:04:46,450 --> 00:04:48,893
所以在这种情况下，这将有一个用户密钥，

97
00:04:49,820 --> 00:04:54,280
所以这里变成了 props.users 而不是 this.users。

98
00:04:54,280 --> 00:04:56,120
我们在所有地方都这样做

99
00:04:56,120 --> 00:04:58,653
我们在这里访问 this.users。

100
00:05:00,210 --> 00:05:03,170
再次在这里，而不是 this.activeSearchTerm，

101
00:05:03,170 --> 00:05:05,403
它是 activeSearchTerm.value，

102
00:05:07,410 --> 00:05:11,200
这就是迁移的计算属性代码。

103
00:05:11,200 --> 00:05:15,570
现在我将我的计算属性命名为avaliableUsers，

104
00:05:15,570 --> 00:05:18,470
因为这也是我们在这里使用的名称

105
00:05:18,470 --> 00:05:20,190
在选项 API 中。

106
00:05:20,190 --> 00:05:24,773
但是有了这个，我们迁移了这个计算属性。

107
00:05:26,010 --> 00:05:28,760
现在让我们处理另一个计算属性，

108
00:05:28,760 --> 00:05:30,950
为此，我已经可以复制代码

109
00:05:30,950 --> 00:05:35,340
我们在displayUsers里面有，所以复制那个代码。

110
00:05:35,340 --> 00:05:37,460
但由于它与排序有关，

111
00:05:37,460 --> 00:05:40,770
我现在将其放在我的排序参考下方，

112
00:05:40,770 --> 00:05:43,210
再次，以便我保留所有搜索逻辑

113
00:05:43,210 --> 00:05:44,700
一起在一个地方

114
00:05:44,700 --> 00:05:47,280
然后将排序逻辑放在一个地方。

115
00:05:47,280 --> 00:05:49,157
这是关键优势之一

116
00:05:49,157 --> 00:05:51,623
Composition API 可以为我们提供。

117
00:05:52,980 --> 00:05:56,780
所以在这里我有我使用计算的显示用户

118
00:06:00,390 --> 00:06:04,950
我这里有一个函数，复制代码。

119
00:06:04,950 --> 00:06:07,730
然后在这里，我指的是这种排序，

120
00:06:07,730 --> 00:06:10,090
好吧，这就是我在这里的排序参考。

121
00:06:10,090 --> 00:06:14,300
所以不是this.sorting，而是sorting.value，

122
00:06:14,300 --> 00:06:16,340
this.availableUsers 不起作用

123
00:06:16,340 --> 00:06:19,720
因为 availableUsers 是我从那里计算出来的属性

124
00:06:19,720 --> 00:06:23,450
和您在本模块中学习的计算属性

125
00:06:23,450 --> 00:06:26,470
都只是参考，只读参考，

126
00:06:26,470 --> 00:06:29,263
他们还为您提供访问 .value 那里，

127
00:06:30,230 --> 00:06:34,770
当然它不仅在那里，而且在这里，

128
00:06:34,770 --> 00:06:36,760
顺便说一句，我在这里调用 slice，

129
00:06:36,760 --> 00:06:40,060
首先创建此数组的副本，

130
00:06:40,060 --> 00:06:42,600
因为否则我也会对现有数组进行排序，

131
00:06:42,600 --> 00:06:45,973
我不想这样做，我想返回一个新的排序数组。

132
00:06:47,170 --> 00:06:51,470
他重新，它再次排序.value，

133
00:06:51,470 --> 00:06:53,330
然后在所有这些地方，

134
00:06:53,330 --> 00:06:58,077
它是sorting.value，就像那样..

135
00:06:59,810 --> 00:07:02,653
有了这个，我们迁移到了我们的displayedUsers。

136
00:07:04,010 --> 00:07:07,270
所以我们可以注释掉整个计算属性块

137
00:07:07,270 --> 00:07:12,270
现在，让我在这里和方法之一。

138
00:07:13,890 --> 00:07:16,000
这里我们得到了一个与搜索相关的方法

139
00:07:16,000 --> 00:07:17,890
和一个与排序有关的

140
00:07:17,890 --> 00:07:22,370
在 updateSearch 中，我刚刚更新了我的 enterSearchTerm。

141
00:07:22,370 --> 00:07:25,950
我只是要复制这个，整个方法

142
00:07:25,950 --> 00:07:28,170
并转到我的搜索功能，

143
00:07:28,170 --> 00:07:31,390
也许在计算属性下方

144
00:07:31,390 --> 00:07:34,910
并添加一个函数，然后复制该名称，

145
00:07:34,910 --> 00:07:37,520
updateSearch，我得到一个值。

146
00:07:37,520 --> 00:07:40,540
而现在当然不是 this.enteredSearchTerm，

147
00:07:40,540 --> 00:07:42,710
但输入了SearchTerm.value

148
00:07:42,710 --> 00:07:45,363
这等于用户选择的 val。

149
00:07:47,400 --> 00:07:52,040
有了这个，我们可以继续在这里的排序方法

150
00:07:52,040 --> 00:07:55,160
并且已经注释掉了我猜的方法，

151
00:07:55,160 --> 00:07:58,440
并将该排序方法置于我们的排序逻辑之下

152
00:07:58,440 --> 00:08:03,263
进入设置方法，所以就在这里，

153
00:08:04,290 --> 00:08:07,270
我现在添加一个新的函数排序

154
00:08:08,850 --> 00:08:12,490
我在哪里设置sorting.value = mode，

155
00:08:12,490 --> 00:08:13,963
参考我的排序参考，

156
00:08:15,750 --> 00:08:18,250
并且我们迁移了方法。

157
00:08:18,250 --> 00:08:22,350
现在我们要观察者，这个观察者基本上就在这里

158
00:08:22,350 --> 00:08:25,890
不要在每次击键时更新搜索逻辑，

159
00:08:25,890 --> 00:08:29,850
但是会增加一点延迟，并且仅当用户输入的内容

160
00:08:29,850 --> 00:08:33,299
在 300 毫秒内没有变化

161
00:08:33,299 --> 00:08:36,610
只有这样我才想把它当作一次新的搜索之旅，

162
00:08:36,610 --> 00:08:38,610
这就是我最后的逻辑。

163
00:08:39,780 --> 00:08:43,159
因此，复制我在观察者中的这个逻辑

164
00:08:44,049 --> 00:08:46,460
然后注释掉是观察者。

165
00:08:46,460 --> 00:08:50,330
现在，因为我想添加一个与搜索相关的观察者，

166
00:08:50,330 --> 00:08:53,380
我首先从 Vue 导入手表

167
00:08:54,260 --> 00:08:58,500
然后可能在下面计算属性，

168
00:08:58,500 --> 00:09:02,050
我们可以调用 watch，并作为第二个参数

169
00:09:02,050 --> 00:09:04,380
传入一个保存该代码的函数

170
00:09:04,380 --> 00:09:07,450
我刚刚从 Options API watcher 复制，

171
00:09:07,450 --> 00:09:10,210
当然设置观察者的依赖，

172
00:09:10,210 --> 00:09:12,290
这是输入的搜索词。

173
00:09:12,290 --> 00:09:14,710
所以点这里输入的搜索词

174
00:09:14,710 --> 00:09:18,130
让 Vue 清楚地知道这个函数应该运行

175
00:09:18,130 --> 00:09:20,593
每当输入的搜索词更改时。

176
00:09:21,810 --> 00:09:23,350
在这里，我们然后得到我们的 newValue

177
00:09:24,820 --> 00:09:27,480
然后比较一个 newValue

178
00:09:27,480 --> 00:09:32,373
到我们当前在输入的SearchTerm.value 中的值，

179
00:09:33,340 --> 00:09:37,650
我想设置 activeSearchTerm.value = newValue

180
00:09:38,940 --> 00:09:41,460
如果我们在这里没有区别，

181
00:09:41,460 --> 00:09:43,680
所以如果用户没有改变输入

182
00:09:43,680 --> 00:09:45,943
持续 300 毫秒。

183
00:09:47,090 --> 00:09:50,890
现在，我已经迁移了所有逻辑，

184
00:09:50,890 --> 00:09:54,290
现在是暴露事情的时候了

185
00:09:54,290 --> 00:09:56,940
我们需要在模板中进行模板。

186
00:09:56,940 --> 00:09:58,810
所以在这个设置函数的最后，

187
00:09:58,810 --> 00:10:01,580
现在我们将添加我们返回的对象

188
00:10:01,580 --> 00:10:03,180
现在归还所有的东西

189
00:10:03,180 --> 00:10:05,070
这应该可用于模板。

190
00:10:05,070 --> 00:10:07,970
例如，enteredSearchTerm，

191
00:10:07,970 --> 00:10:09,480
我们在这里使用它。

192
00:10:09,480 --> 00:10:11,910
我们还需要 updateSearch 功能，

193
00:10:11,910 --> 00:10:13,063
正如我们在这里看到的。

194
00:10:14,330 --> 00:10:17,863
我们需要对 ref 进行排序，因为我们可以看到我们在这里使用它。

195
00:10:18,750 --> 00:10:23,030
我们需要排序功能，你可以在这里看到。

196
00:10:23,030 --> 00:10:27,343
我们需要显示用户，应该就是这样。

197
00:10:29,270 --> 00:10:32,040
我什至注意到这里有一个小故障，

198
00:10:32,040 --> 00:10:33,810
我在这里发出一个自定义事件

199
00:10:33,810 --> 00:10:36,110
当然我们应该在这里添加发射，

200
00:10:36,110 --> 00:10:37,860
那应该是之前添加的

201
00:10:37,860 --> 00:10:40,500
也可以使用 Options API。

202
00:10:40,500 --> 00:10:41,830
嗯，我刚注意到，

203
00:10:41,830 --> 00:10:45,070
所以要遵循这里的所有最佳实践，

204
00:10:45,070 --> 00:10:50,070
让我们在这里添加列表项目作为发出的事件，

205
00:10:50,450 --> 00:10:53,310
但这只是之前应该添加的旁注。

206
00:10:53,310 --> 00:10:55,570
现在让我们公开我们需要的东西

207
00:10:55,570 --> 00:11:00,257
那就是输入的搜索词，显示的用户，

208
00:11:02,944 --> 00:11:07,420
updateSearch 函数，排序参考，

209
00:11:07,420 --> 00:11:11,263
和排序功能，我想就是这样。

210
00:11:12,120 --> 00:11:17,120
所以排序和排序，我得到一个错误，

211
00:11:19,860 --> 00:11:21,630
availableUser 被赋值，

212
00:11:21,630 --> 00:11:23,133
看来我有错字

213
00:11:26,359 --> 00:11:28,290
这应该是可用的用户在这里，

214
00:11:28,290 --> 00:11:29,983
我的计算机财产的名称。

215
00:11:31,300 --> 00:11:33,700
有了它，它编译，

216
00:11:33,700 --> 00:11:35,770
如果我重新加载，这看起来不错。

217
00:11:35,770 --> 00:11:37,440
让我打开开发工具看看

218
00:11:37,440 --> 00:11:39,320
如果我们在这里有任何错误

219
00:11:39,320 --> 00:11:44,320
和排序似乎工作，搜索所有的作品，

220
00:11:46,020 --> 00:11:50,160
并且选择一个用户似乎也可以在这里解决问题。

221
00:11:50,160 --> 00:11:53,090
所以看起来应用程序和以前一样工作

222
00:11:53,090 --> 00:11:55,710
然后，我们迁移了用户列表

223
00:11:55,710 --> 00:11:57,570
您从 Options API 中找到的，

224
00:11:57,570 --> 00:12:01,930
您仍然可以在那里看到 Composition API。

225
00:12:01,930 --> 00:12:04,310
当然，这仍然是很多代码，

226
00:12:04,310 --> 00:12:07,260
我的意思是，逻辑的数量并没有真正改变，

227
00:12:07,260 --> 00:12:11,010
但一个优势，一个可能的优势是

228
00:12:11,010 --> 00:12:14,750
现在所有的搜索功能都在一个块中

229
00:12:14,750 --> 00:12:18,740
所有的排序功能都在一个代码块中。

230
00:12:18,740 --> 00:12:22,200
这可以使管理这样的组件更容易

231
00:12:22,200 --> 00:12:24,100
因为你不必滚动太多，

232
00:12:24,100 --> 00:12:26,580
如果我需要更改与搜索相关的内容，

233
00:12:26,580 --> 00:12:30,400
它都在那个区域，而不是组件的某个地方。

234
00:12:30,400 --> 00:12:32,510
现在，当然，这对你来说可能重要也可能不重要，

235
00:12:32,510 --> 00:12:35,763
但它在更大的组件中可能是一个优势。