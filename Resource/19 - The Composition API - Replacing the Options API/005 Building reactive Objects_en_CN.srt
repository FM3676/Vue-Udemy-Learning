1
00:00:02,420 --> 00:00:04,059
所以现在我们介绍了 ref，

2
00:00:04,059 --> 00:00:06,420
这创造了反应价值。

3
00:00:06,420 --> 00:00:10,140
Vue 观察到哪些值会发生变化

4
00:00:10,140 --> 00:00:12,710
反映在模板中。

5
00:00:12,710 --> 00:00:14,870
现在，让我们添加第二个值。

6
00:00:14,870 --> 00:00:16,960
比方说，除了用户名，

7
00:00:16,960 --> 00:00:19,833
我们还想输出年龄。

8
00:00:21,710 --> 00:00:25,190
因此，我们可以简单地创建一个 uAge 常量，

9
00:00:25,190 --> 00:00:30,190
例如，第二个参考，例如，带有一个数字。

10
00:00:30,420 --> 00:00:35,420
现在在这里，我也在我的对象中暴露了年龄

11
00:00:36,150 --> 00:00:37,580
我用年龄作为关键

12
00:00:37,580 --> 00:00:39,983
因为我在模板中使用了年龄。

13
00:00:40,840 --> 00:00:42,093
年龄的值为uAge。

14
00:00:44,110 --> 00:00:48,462
如果我们这样做，我们也会看到这里的年龄。

15
00:00:48,462 --> 00:00:51,410
当然我们现在也可以改变年龄

16
00:00:51,410 --> 00:00:53,870
如果我们愿意，可以在我们的计时器中。

17
00:00:53,870 --> 00:00:57,640
我们可以在两秒钟后分配一个新值

18
00:00:57,640 --> 00:01:00,170
所以如果我们在两秒后重新加载

19
00:01:00,170 --> 00:01:02,863
名字和年龄都变了。

20
00:01:04,769 --> 00:01:07,810
现在因为我们有两条数据，

21
00:01:07,810 --> 00:01:11,230
名字和年龄，哪一种属于一起，

22
00:01:11,230 --> 00:01:14,550
我们也可以考虑将它们组合在一起。

23
00:01:14,550 --> 00:01:18,400
所以在这里，而不是创建两个 refs

24
00:01:18,400 --> 00:01:22,970
使用两个单独的值，我们可以创建一个用户，

25
00:01:22,970 --> 00:01:27,010
常量，并在此处创建一个包含对象的 ref。

26
00:01:27,010 --> 00:01:30,390
在一个对象中我们有一个名字，马克西米利安

27
00:01:30,390 --> 00:01:32,613
我们有一个年龄，31岁。

28
00:01:33,700 --> 00:01:35,910
所以现在我们仍然有一个反应值，

29
00:01:35,910 --> 00:01:39,000
但现在它是我们将数据组合在一起的对象

30
00:01:39,000 --> 00:01:41,243
而不是有两个单独的值。

31
00:01:42,700 --> 00:01:45,440
现在我们可以公开用户名

32
00:01:45,440 --> 00:01:50,280
通过从 user.value.name 获取它。

33
00:01:50,280 --> 00:01:52,840
请记住，用户因此是参考

34
00:01:52,840 --> 00:01:54,310
它有一个价值属性

35
00:01:54,310 --> 00:01:57,190
并且该值包含我们在这里存储的实际值

36
00:01:57,190 --> 00:01:59,660
所以具有 name 属性的对象。

37
00:01:59,660 --> 00:02:02,220
这里我们有 user.dot.value.age

38
00:02:03,210 --> 00:02:05,070
在 setTimeout 中，

39
00:02:05,070 --> 00:02:08,100
而不是改变这两个单独的值，

40
00:02:08,100 --> 00:02:13,100
我们现在设置 user.value.name 等于 Max

41
00:02:13,530 --> 00:02:16,683
并将 user.value.age 设置为 32。

42
00:02:17,900 --> 00:02:22,320
如果我们保存并重新加载，我们会看到 Maximilian 和 31，

43
00:02:22,320 --> 00:02:26,510
但两秒钟后，什么也没有发生。

44
00:02:26,510 --> 00:02:28,503
数据不会在此处更新。

45
00:02:30,180 --> 00:02:32,600
嗯，这是有原因的。

46
00:02:32,600 --> 00:02:36,650
当您使用 ref 函数创建 ref 时，

47
00:02:36,650 --> 00:02:39,670
你得到一个对象，Vue 给你一个对象。

48
00:02:39,670 --> 00:02:44,670
如果我们在这里使用控制台日志进行 console.log ，我们可以看到这一点，

49
00:02:45,320 --> 00:02:48,390
如果我重新加载，那就是我们的 ref 对象

50
00:02:48,390 --> 00:02:50,940
我们得到了这个价值属性

51
00:02:50,940 --> 00:02:53,310
我们实际上得到了这样的代理。

52
00:02:53,310 --> 00:02:56,670
您可能会从幕后模块中注意到此代理

53
00:02:56,670 --> 00:02:58,313
我们在课程的早些时候。

54
00:02:59,400 --> 00:03:01,740
我们还有一个 getter 和一个 setter

55
00:03:01,740 --> 00:03:04,340
在整个 ref 对象上。

56
00:03:04,340 --> 00:03:08,160
有了这些，Vue 可以跟踪读写访问

57
00:03:08,160 --> 00:03:12,220
到 value 属性，这样如果你，例如，

58
00:03:12,220 --> 00:03:16,410
访问 user.value 并分配一个全新的对象

59
00:03:16,410 --> 00:03:18,753
Vue 能够接受这种变化。

60
00:03:19,970 --> 00:03:24,970
但此外，如果您将对象作为值传递给 ref

61
00:03:25,360 --> 00:03:30,080
该对象也被代理包裹，因此 Vue

62
00:03:30,080 --> 00:03:35,080
甚至能够跟踪该对象的内部变化。

63
00:03:35,330 --> 00:03:38,930
因此，例如在这里，当您钻入对象时

64
00:03:38,930 --> 00:03:42,123
然后你指定一个新的名字和年龄，就像我们在这里做的那样。

65
00:03:43,580 --> 00:03:45,610
尽管如此，你也可以看到

66
00:03:45,610 --> 00:03:48,870
Vue 无法更新屏幕，

67
00:03:48,870 --> 00:03:50,480
即使我只是告诉你

68
00:03:50,480 --> 00:03:53,200
它会接受这些变化。

69
00:03:53,200 --> 00:03:57,960
问题是，我们如何将它传递给我们的模板。

70
00:03:57,960 --> 00:04:01,810
这里我们也深入到这个对象

71
00:04:01,810 --> 00:04:06,010
使用用户点值，我们访问存储在 ref 中的对象

72
00:04:06,010 --> 00:04:08,990
然后是名称和年龄属性。

73
00:04:08,990 --> 00:04:11,430
这就是我们在这里遇到的问题

74
00:04:11,430 --> 00:04:14,550
名字和年龄，这些属性，

75
00:04:14,550 --> 00:04:18,459
name 和 age 的值，所以所有这些属性

76
00:04:18,459 --> 00:04:21,600
只是普通的字符串和数字。

77
00:04:21,600 --> 00:04:25,840
这些不是反应值。

78
00:04:25,840 --> 00:04:29,720
因此，虽然 Vue 在理论上确实会

79
00:04:29,720 --> 00:04:33,220
有可能告诉用户发生了一些变化，

80
00:04:33,220 --> 00:04:37,800
它不明白我们最终会暴露用户

81
00:04:37,800 --> 00:04:42,050
到我们的模板，因为我们正在像这样钻研用户。

82
00:04:42,050 --> 00:04:46,710
所以它所看到的只是我们公开了一个字符串和一个数字。

83
00:04:46,710 --> 00:04:50,300
而且由于它不跟踪这些特定值，

84
00:04:50,300 --> 00:04:52,613
它没有检测到那里的任何变化。

85
00:04:54,470 --> 00:04:59,470
现在我们可以在这里做的一件事就是我们可以提供

86
00:04:59,470 --> 00:05:03,330
整个用户对象在这里。

87
00:05:03,330 --> 00:05:07,800
所以我们的用户引用在模板的用户键下

88
00:05:07,800 --> 00:05:09,853
并在那里输出。

89
00:05:11,070 --> 00:05:15,080
例如，如果我在这里临时添加一个段落，

90
00:05:15,080 --> 00:05:18,600
我现在可以输出用户，因为我们正在暴露

91
00:05:18,600 --> 00:05:22,790
这个用户密钥在这里，如果我这样做，

92
00:05:22,790 --> 00:05:25,330
确实，你会在这里看到我的对象，你会看到

93
00:05:25,330 --> 00:05:28,030
两秒钟后它也发生了变化。

94
00:05:28,030 --> 00:05:28,973
干得好。

95
00:05:31,050 --> 00:05:35,997
因此，我们当然也可以输出 user.name

96
00:05:36,910 --> 00:05:39,490
或 user.age 这里。

97
00:05:39,490 --> 00:05:42,900
所以在模板中钻入这个对象

98
00:05:42,900 --> 00:05:45,160
现在如果我重新加载它会起作用，

99
00:05:45,160 --> 00:05:47,200
两秒钟后它会更新。

100
00:05:47,200 --> 00:05:49,840
因为现在我还在钻研这个，

101
00:05:49,840 --> 00:05:54,480
但仅在模板中，我传递了原始对象，

102
00:05:54,480 --> 00:05:58,020
此处模板的原始 ref 对象

103
00:05:58,020 --> 00:06:00,893
在我的设置函数的返回语句中。

104
00:06:01,820 --> 00:06:03,940
这对 Vue 来说很重要。

105
00:06:03,940 --> 00:06:07,630
有了它，它就得到了这个原始的 ref 对象。

106
00:06:07,630 --> 00:06:12,120
它具有该对象中的所有反应性并且它知道

107
00:06:12,120 --> 00:06:14,810
当我们分配一个新值并且它知道

108
00:06:14,810 --> 00:06:16,620
我们在模板中使用它

109
00:06:16,620 --> 00:06:20,330
所以它继续，在模板中找到位置

110
00:06:20,330 --> 00:06:24,053
我们在哪里使用这个对象并更新那个代码。

111
00:06:26,710 --> 00:06:30,020
这就是我们正确使用 ref 的方式

112
00:06:30,020 --> 00:06:34,303
使用对象而不是单独的值。

113
00:06:35,580 --> 00:06:38,700
但如果你正在处理一个对象，

114
00:06:38,700 --> 00:06:41,870
实际上有一个更好的替代参考。

115
00:06:41,870 --> 00:06:45,460
而不是使用 ref，你可以像这样使用它。

116
00:06:45,460 --> 00:06:48,890
当然，顺便说一句，您现在可以删除所有这些。

117
00:06:48,890 --> 00:06:51,660
只暴露用户就足够了，

118
00:06:51,660 --> 00:06:56,090
但您现在也可以导入，而不是使用 ref

119
00:06:56,090 --> 00:07:00,703
反应函数，这都是 Vue 提供的。

120
00:07:02,070 --> 00:07:05,000
Reactive 有点像 ref，

121
00:07:05,000 --> 00:07:08,240
但它是明确为对象制作的。

122
00:07:08,240 --> 00:07:12,170
所以现在我们调用响应式而不是 ref

123
00:07:12,170 --> 00:07:15,473
你仍然将你的对象传递给响应式。

124
00:07:16,725 --> 00:07:21,490
但是 ref 使用任何类型的值，字符串，

125
00:07:21,490 --> 00:07:26,490
数字和对象，反应式仅适用于此处的对象。

126
00:07:27,050 --> 00:07:30,173
因此，您必须将对象传递给响应式。

127
00:07:31,320 --> 00:07:34,190
现在响应式做了一件重要的事情。

128
00:07:34,190 --> 00:07:37,270
它不会用额外的对象包装它

129
00:07:37,270 --> 00:07:41,010
它有一个 value 道具，然后指向你的价值。

130
00:07:41,010 --> 00:07:44,710
相反，它使这个对象ch 你传递给响应式，

131
00:07:44,710 --> 00:07:48,010
通过将其包装到代理中进行反应

132
00:07:48,010 --> 00:07:50,860
这样您仍然可以使用此对象

133
00:07:50,860 --> 00:07:55,040
就好像你只拥有那个没有任何包装器的对象一样。

134
00:07:55,040 --> 00:07:58,440
当我们看到这个控制台日志时，我们也可以很快看到这一点，

135
00:07:58,440 --> 00:08:00,900
但这意味着不是访问

136
00:08:00,900 --> 00:08:04,900
用户点值点名和用户点值点年龄，

137
00:08:04,900 --> 00:08:09,900
您现在只访问用户点名称和用户点年龄。

138
00:08:12,250 --> 00:08:14,740
所以我们可以跳过这个点值步骤

139
00:08:14,740 --> 00:08:18,200
因为没有带有 value 属性的包装对象。

140
00:08:18,200 --> 00:08:20,170
因为我们这里已经有一个对象

141
00:08:20,170 --> 00:08:21,683
我们正在使用反应式。

142
00:08:22,670 --> 00:08:25,700
现在说到曝光，我们还是曝光

143
00:08:25,700 --> 00:08:27,480
正如我们对 ref 所做的那样，

144
00:08:27,480 --> 00:08:31,480
我们暴露整个对象，我们不钻入它

145
00:08:31,480 --> 00:08:34,789
给 Vue 整个响应式对象。

146
00:08:34,789 --> 00:08:38,020
我们现在可以删除那些其他属性

147
00:08:38,020 --> 00:08:42,020
我们在这里分享，然后我们可以使用用户点名

148
00:08:42,020 --> 00:08:43,120
和用户点年龄。

149
00:08:43,120 --> 00:08:46,050
所以和以前一样，关键的区别是

150
00:08:46,050 --> 00:08:49,450
我们现在没有这个额外的包装对象

151
00:08:49,450 --> 00:08:51,830
具有点值属性。

152
00:08:51,830 --> 00:08:54,390
所以只是把这个带回来作为比较

153
00:08:54,390 --> 00:08:58,930
在使用那些单独的值参考之前，

154
00:08:58,930 --> 00:09:02,530
我们有 uName.value 等于 Max

155
00:09:02,530 --> 00:09:06,143
我们的 uAge.value 等于 32。

156
00:09:07,370 --> 00:09:11,220
现在我们直接使用我们的对象，就好像它是

157
00:09:11,220 --> 00:09:15,610
一个常规的 JavaScript 对象，但它实际上是响应式的。

158
00:09:15,610 --> 00:09:18,223
因此，如果您保存并重新加载，

159
00:09:19,340 --> 00:09:22,690
我们仍然看到它在两秒钟后发生了变化。

160
00:09:22,690 --> 00:09:25,520
现在，关于我们的控制台日志的注释在这里，

161
00:09:25,520 --> 00:09:30,000
我在哪里记录用户，在它是这个 ref 对象之前

162
00:09:30,000 --> 00:09:31,600
具有价值属性

163
00:09:31,600 --> 00:09:34,240
以及价值的获取者和设置者。

164
00:09:34,240 --> 00:09:36,840
现在是这个代理对象，

165
00:09:36,840 --> 00:09:39,880
它包装了我们的对象，并且简单地具有

166
00:09:39,880 --> 00:09:43,800
这些内部侦听器会更改我们的属性。

167
00:09:43,800 --> 00:09:45,400
基本上我已经介绍过

168
00:09:45,400 --> 00:09:47,113
在幕后模块中。

169
00:09:48,500 --> 00:09:51,600
然后，我将删除此控制台日志

170
00:09:51,600 --> 00:09:54,620
并留下该代码，因为现在就是这样，

171
00:09:54,620 --> 00:09:57,880
当我们谈论管理响应式数据时。

172
00:09:57,880 --> 00:10:02,880
你有 refs 和响应式，响应式用于对象，

173
00:10:03,470 --> 00:10:08,080
refs 适用于各种值，包括对象

174
00:10:08,080 --> 00:10:11,323
如果您对这种额外的点值访问感到满意。

175
00:10:12,280 --> 00:10:14,310
这取决于你喜欢哪一个。

176
00:10:14,310 --> 00:10:16,600
如果您正在处理一个对象，您可以选择

177
00:10:16,600 --> 00:10:19,470
在反应和参考之间，如果你有什么

178
00:10:19,470 --> 00:10:23,620
但是一个对象，比如一个字符串或一个数字，它总是一个引用。

179
00:10:23,620 --> 00:10:26,290
是否要对数据进行分组始终取决于您

180
00:10:26,290 --> 00:10:29,510
组合成一个对象或单独管理数据

181
00:10:29,510 --> 00:10:30,980
就像我们之前做的那样。

182
00:10:30,980 --> 00:10:33,710
这里没有错误或正确的方法，

183
00:10:33,710 --> 00:10:37,360
这取决于您的偏好、数据类型、

184
00:10:37,360 --> 00:10:39,050
你团队的其他成员怎么说

185
00:10:39,050 --> 00:10:41,563
总的来说，当然是您的应用程序。

186
00:10:42,400 --> 00:10:44,390
现在你知道这两个重要的

187
00:10:44,390 --> 00:10:46,440
虽然数据管理概念，

188
00:10:46,440 --> 00:10:49,580
对于反应性数据，参考和反应性。

189
00:10:49,580 --> 00:10:51,730
有了这个，让我们更深入地挖掘

190
00:10:51,730 --> 00:10:55,003
让我们看看我们还能用 Composition API 做什么。