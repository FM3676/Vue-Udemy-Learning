1
00:00:02,150 --> 00:00:04,710
现在也许你还记得最初

2
00:00:04,710 --> 00:00:07,230
我展示了一个更大的项目

3
00:00:07,230 --> 00:00:10,210
作为我们可能想要的一个例子

4
00:00:10,210 --> 00:00:13,580
考虑使用组合 API。

5
00:00:13,580 --> 00:00:15,770
我在一开始就展示了这个例子

6
00:00:15,770 --> 00:00:17,830
组合 API 模块，

7
00:00:17,830 --> 00:00:19,640
在该模块的最后，

8
00:00:19,640 --> 00:00:23,520
我们从 Options API 迁移了该项目

9
00:00:23,520 --> 00:00:25,173
到组合 API。

10
00:00:26,370 --> 00:00:30,700
现在你会发现本次讲座附带的最新快照，

11
00:00:30,700 --> 00:00:33,670
因为我想了解它，我想从那里开始

12
00:00:33,670 --> 00:00:37,230
现在谈谈重用功能

13
00:00:37,230 --> 00:00:40,570
因为那是我们在那个项目中没有做过的事情

14
00:00:40,570 --> 00:00:41,900
到那时为止。

15
00:00:41,900 --> 00:00:46,410
当我们将其迁移到 Composition API 时，我们停止了，

16
00:00:46,410 --> 00:00:50,410
但现在我想重用一些功能。

17
00:00:50,410 --> 00:00:53,110
并且有一个主要功能

18
00:00:53,110 --> 00:00:55,060
我想重用它。

19
00:00:55,060 --> 00:00:59,780
在 UserList.vue 中，我得到了搜索功能，

20
00:00:59,780 --> 00:01:02,950
两条数据，一个计算属性，

21
00:01:02,950 --> 00:01:06,150
和一个观察者和这个功能。

22
00:01:06,150 --> 00:01:10,410
我们在 ProjectsList 中几乎相同

23
00:01:10,410 --> 00:01:13,040
我们在那里处理不同的数据，

24
00:01:13,040 --> 00:01:15,960
在这里，我们有一个我们过滤的项目列表，

25
00:01:15,960 --> 00:01:19,990
在 UserList 我们有一个用户列表，但除此之外，

26
00:01:19,990 --> 00:01:21,793
这是相同的功能。

27
00:01:22,760 --> 00:01:25,760
那么让我们看看我们现在如何使用自定义钩子

28
00:01:25,760 --> 00:01:28,310
将其外包给一个函数

29
00:01:28,310 --> 00:01:32,003
然后我们可以在 UserList 和 ProjectsList 中使用它。

30
00:01:33,070 --> 00:01:36,630
为此，我将在接下来的两个组件中添加一个新文件夹，

31
00:01:36,630 --> 00:01:38,400
我会再次将其命名为钩子。

32
00:01:38,400 --> 00:01:41,940
在那里我将添加一个 search.js 文件。

33
00:01:41,940 --> 00:01:45,070
在那里我将添加一个函数，useSearch，

34
00:01:45,070 --> 00:01:48,400
遵循我推荐的命名模式，

35
00:01:48,400 --> 00:01:52,120
我已经将其导出，因为我打算使用

36
00:01:52,120 --> 00:01:54,113
并在 UserList 和 ProjectsList 中调用 useSearch。

37
00:01:58,040 --> 00:01:58,960
现在，正如我提到的，

38
00:01:58,960 --> 00:02:02,240
我们有很多共同的功能。

39
00:02:02,240 --> 00:02:05,080
那么我们为什么不直接去 UserList

40
00:02:05,080 --> 00:02:08,720
也许在这里获取所有代码？

41
00:02:08,720 --> 00:02:13,560
所以这两个 refs，计算的属性，availableUsers，

42
00:02:13,560 --> 00:02:16,690
观察者，以及这个 updateSearch 函数

43
00:02:17,610 --> 00:02:20,530
并将其复制到 search.js

44
00:02:20,530 --> 00:02:24,103
像这样进入我们的 useSearch 函数。

45
00:02:27,020 --> 00:02:28,700
现在我们需要添加一个导入

46
00:02:29,590 --> 00:02:31,850
因为我使用了一堆功能

47
00:02:31,850 --> 00:02:34,400
该文件中尚不可用。

48
00:02:34,400 --> 00:02:37,380
ref 函数，计算函数，

49
00:02:37,380 --> 00:02:40,800
手表功能，是的，应该是它。

50
00:02:40,800 --> 00:02:42,880
所以我们应该添加一个导入

51
00:02:42,880 --> 00:02:45,460
并从视图框架导入，

52
00:02:45,460 --> 00:02:46,670
特别是，

53
00:02:46,670 --> 00:02:49,630
我想导入参考，计算和观看，

54
00:02:49,630 --> 00:02:51,450
因为这是三个功能

55
00:02:51,450 --> 00:02:53,223
我现在在这个文件中使用。

56
00:02:54,330 --> 00:02:57,800
这样，该代码几乎可以正常工作，

57
00:02:57,800 --> 00:02:59,720
虽然不完全。

58
00:02:59,720 --> 00:03:02,200
我们将面临的一个问题

59
00:03:02,200 --> 00:03:05,860
是我们依赖于 props.users 过滤器。

60
00:03:05,860 --> 00:03:08,950
现在在此功能中，道具不可用。

61
00:03:08,950 --> 00:03:12,160
即使我们稍后在设置方法中调用它

62
00:03:12,160 --> 00:03:15,763
功能障碍范围内的道具不存在。

63
00:03:17,020 --> 00:03:18,930
但是我们当然可以解决这个问题。

64
00:03:18,930 --> 00:03:22,650
我们可以简单地添加一个参数并将其命名为 items

65
00:03:22,650 --> 00:03:26,300
具有适用于任何类型项目的通用功能，

66
00:03:26,300 --> 00:03:29,400
不管是人还是项目。

67
00:03:29,400 --> 00:03:32,300
这就是为什么我只是将其命名为 items to 说清楚

68
00:03:32,300 --> 00:03:35,050
这应该适用于任何类型的数组。

69
00:03:35,050 --> 00:03:40,050
然后我们可以在这里使用 items.filter

70
00:03:40,300 --> 00:03:44,540
并将 props.users 替换为项目

71
00:03:44,540 --> 00:03:47,423
在这里的其他地方是这样的。

72
00:03:48,610 --> 00:03:51,990
我将在这里重命名我的用户的帮助变量

73
00:03:51,990 --> 00:03:56,530
过滤项目并在所有地方使用它

74
00:03:59,180 --> 00:04:02,563
我使用用户来使其更通用。

75
00:04:03,580 --> 00:04:06,500
我还将重命名整个计算机属性

76
00:04:06,500 --> 00:04:07,500
到一个availableItems，

77
00:04:08,520 --> 00:04:11,120
因为现在不再关注用户，

78
00:04:11,120 --> 00:04:13,483
但在我们想要搜索的任何项目上。

79
00:04:14,860 --> 00:04:16,820
现在，我们仍然会遇到问题。

80
00:04:16,820 --> 00:04:19,860
此处传递给过滤器的函数

81
00:04:19,860 --> 00:04:23,070
有特定的过滤逻辑

82
00:04:23,070 --> 00:04:26,150
这只适用于我们的用户

83
00:04:26,150 --> 00:04:28,573
因为在这里我过滤的是全名。

84
00:04:29,430 --> 00:04:32,983
例如，在 ProjectsList 中，我正在过滤标题。

85
00:04:33,820 --> 00:04:36,910
现在有两种方法可以完成这项工作。

86
00:04:36,910 --> 00:04:40,010
我们可以接受这个过滤功能

87
00:04:40,010 --> 00:04:43,910
作为数字参数，过滤函数，

88
00:04:43,910 --> 00:04:48,910
例如，我们就这样通过这里，

89
00:04:50,720 --> 00:04:52,580
那将是一种选择。

90
00:04:52,580 --> 00:04:54,750
然后我们必须传入函数

91
00:04:54,750 --> 00:04:57,020
应该从这里使用的地方

92
00:04:57,020 --> 00:04:59,320
我们称之为useSearch。

93
00:04:59,320 --> 00:05:04,320
或者如果我们知道我们将始终对一个项目进行操作，

94
00:05:04,590 --> 00:05:07,720
但是保存文本的属性

95
00:05:07,720 --> 00:05:09,200
我们想用于过滤

96
00:05:09,200 --> 00:05:11,540
一直有不同的名字，

97
00:05:11,540 --> 00:05:14,430
那么我们也可以只接受第二个论点，

98
00:05:14,430 --> 00:05:17,350
存储该特定属性名称

99
00:05:17,350 --> 00:05:22,350
关闭我们试图在给定组件中搜索的值。

100
00:05:22,480 --> 00:05:24,180
那么例如在这里，

101
00:05:24,180 --> 00:05:27,630
我们可以添加一个搜索道具或任何你想命名的东西，

102
00:05:27,630 --> 00:05:32,303
参数，并简单地访问 userSearchProp。

103
00:05:34,870 --> 00:05:38,600
所以根据值动态访问一个属性

104
00:05:38,600 --> 00:05:40,083
我们得到这个参数。

105
00:05:40,950 --> 00:05:45,260
并且可能将其从用户重命名为项目。

106
00:05:45,260 --> 00:05:46,930
所以两者都有效，但是，

107
00:05:46,930 --> 00:05:49,933
我们这里有一个更灵活的过滤逻辑。

108
00:05:51,960 --> 00:05:54,270
现在我们这里也有一个观察者

109
00:05:54,270 --> 00:05:56,759
我们在其中观察输入的SearchTerm。

110
00:05:56,759 --> 00:05:57,880
每当搜索词发生变化时，

111
00:06:00,082 --> 00:06:03,540
我们触发这个函数并设置这个定时器。

112
00:06:03,540 --> 00:06:06,630
现在，在这里我们可以保持原样

113
00:06:06,630 --> 00:06:10,230
因为enteredSearchTerm 和activeSearchTerm

114
00:06:10,230 --> 00:06:12,600
是在这个函数中定义的 refs

115
00:06:12,600 --> 00:06:14,373
因此将可用。

116
00:06:15,520 --> 00:06:18,640
updateSearch 也应该可以工作。

117
00:06:18,640 --> 00:06:19,473
因此，

118
00:06:19,473 --> 00:06:20,740
我们唯一要做的

119
00:06:20,740 --> 00:06:23,290
是不是我们要退回一堆东西

120
00:06:23,290 --> 00:06:24,530
这样我们就可以使用它们

121
00:06:24,530 --> 00:06:26,380
在组件设置方法中，

122
00:06:26,380 --> 00:06:28,870
我们要调用的地方，useSearch。

123
00:06:30,030 --> 00:06:31,870
正如我所提到的，这是你的职责。

124
00:06:31,870 --> 00:06:34,920
所以这取决于你，你如何归还这些东西

125
00:06:34,920 --> 00:06:38,350
如果您将它们捆绑在一个数组或一个对象中。

126
00:06:38,350 --> 00:06:40,630
在这里，我会去找一个对象。

127
00:06:40,630 --> 00:06:43,493
在我们看到数组之前，两者都是可能的。

128
00:06:44,430 --> 00:06:46,010
在这里，我会去找一个对象。

129
00:06:46,010 --> 00:06:49,610
现在让我们想想我们想要暴露什么

130
00:06:49,610 --> 00:06:52,153
到调用 useSearch 的组件。

131
00:06:53,770 --> 00:06:55,970
为此，让我们回到 UserList

132
00:06:55,970 --> 00:06:57,660
因为那将是一个组件

133
00:06:57,660 --> 00:06:59,860
很快就会使用这个自定义钩子。

134
00:06:59,860 --> 00:07:01,960
让我们看看我们暴露了什么

135
00:07:01,960 --> 00:07:03,660
到这里的模板。

136
00:07:03,660 --> 00:07:05,630
我们正在公开输入的搜索

137
00:07:05,630 --> 00:07:08,230
和 updateSearch 功能。

138
00:07:08,230 --> 00:07:12,250
我们也依赖于这里的availableUsers

139
00:07:12,250 --> 00:07:13,593
在我们显示的用户中。

140
00:07:17,090 --> 00:07:19,760
因此，在我们的自定义钩子中，

141
00:07:19,760 --> 00:07:22,260
我们绝对应该公开输入的SearchTerm，

142
00:07:23,525 --> 00:07:28,160
availableItems 和 updateSearch 函数。

143
00:07:28,160 --> 00:07:30,010
所以我会暴露输入的SearchTerm，

144
00:07:31,421 --> 00:07:34,83​​0
availableItems 和 updateSearch 函数。

145
00:07:34,83​​0 --> 00:07:37,500
这就是我将在我的搜索中返回的内容，

146
00:07:37,500 --> 00:07:41,213
在我的 useSearch 中，对不起，在我的 useSearch 函数中。

147
00:07:42,700 --> 00:07:45,700
现在我们可以去 UserList.vue

148
00:07:45,700 --> 00:07:50,440
暂时把所有这些都评论出来

149
00:07:50,440 --> 00:07:54,293
而是从中导入 useSearch，

150
00:07:58,380 --> 00:08:02,710
上升两个级别，钩子/search.js。

151
00:08:02,710 --> 00:08:05,850
我不会在这里删除这个 Vue 导入

152
00:08:05,850 --> 00:08:07,950
因为我仍在使用参考，

153
00:08:07,950 --> 00:08:11,160
计算属性，没有观察者，

154
00:08:11,160 --> 00:08:13,470
但是那里的 ref 和一个计算属性。

155
00:08:13,470 --> 00:08:15,200
所以我们必须保留它，

156
00:08:15,200 --> 00:08:18,810
但我们可以删除，我们应该删除手表导入

157
00:08:18,810 --> 00:08:21,750
因为我不再在这个文件中使用 watch，

158
00:08:21,750 --> 00:08:23,360
只是参考和计算。

159
00:08:23,360 --> 00:08:25,830
这些仍然在我的设置方法中使用，

160
00:08:25,830 --> 00:08:28,003
即使这段代码被注释掉了。

161
00:08:29,290 --> 00:08:32,667
但是现在这里我们可以调用useSearch，

162
00:08:33,960 --> 00:08:35,919
所以我们自己的功能在这里。

163
00:08:35,919 --> 00:08:39,472
这个函数现在需要两个参数，

164
00:08:40,370 --> 00:08:43,400
项目和我们的 searchProp。

165
00:08:44,640 --> 00:08:49,640
如果您还记得的话，现在是 props.user 的项目。

166
00:08:50,230 --> 00:08:52,740
这就是我们之前在这里使用的。

167
00:08:52,740 --> 00:08:56,827
所以 props.user 是我想输入 useSearch 的。

168
00:08:58,470 --> 00:08:59,900
而对于房产，

169
00:08:59,900 --> 00:09:03,350
我们想用它来过滤每个用户，

170
00:09:03,350 --> 00:09:06,200
那是 fullName 属性，

171
00:09:06,200 --> 00:09:08,950
我们应该将其作为字符串传入。

172
00:09:08,950 --> 00:09:12,200
作为字符串，因为属性名称

173
00:09:12,200 --> 00:09:14,660
在 JavaScript 中，对象是字符串，

174
00:09:14,660 --> 00:09:16,393
所以我们把它作为一个字符串传入。

175
00:09:17,690 --> 00:09:20,330
然后我们在这里取回一些值。

176
00:09:20,330 --> 00:09:21,440
在这种情况下，

177
00:09:21,440 --> 00:09:25,070
我们返回一个对象，因为我返回了一个对象

178
00:09:25,070 --> 00:09:27,320
在我的自定义 useSearch 函数中。

179
00:09:27,320 --> 00:09:30,780
在那里，我们将拥有这三个属性。

180
00:09:30,780 --> 00:09:34,600
所以我们可以在这里再次使用对象解构

181
00:09:35,980 --> 00:09:39,924
使用此语法获取输入的搜索词，

182
00:09:39,924 --> 00:09:43,123
availableItems 和 updateSearch 函数。

183
00:09:43,990 --> 00:09:46,383
EnteredSearchTerm 将是一个参考，

184
00:09:46,383 --> 00:09:48,790
availableItems 是一个计算属性，

185
00:09:48,790 --> 00:09:50,860
因此我们的只读参考

186
00:09:50,860 --> 00:09:52,823
updateSearch 是一个函数。

187
00:09:54,620 --> 00:09:57,270
现在我们可以在这里使用这些东西了。

188
00:09:57,270 --> 00:09:59,640
例如，在显示的用户中，

189
00:09:59,640 --> 00:10:01,970
我依赖于availableUsers。

190
00:10:01,970 --> 00:10:04,490
这是现在可用的物品，

191
00:10:04,490 --> 00:10:06,650
当然我们可以在这里重命名

192
00:10:06,650 --> 00:10:08,450
在这种设置方法中，

193
00:10:08,450 --> 00:10:10,970
如果您想坚持使用availableUsers，

194
00:10:10,970 --> 00:10:13,593
但我只会选择availableItems。

195
00:10:16,190 --> 00:10:17,830
其余的应该没问题。

196
00:10:17,830 --> 00:10:20,650
然后在这里我返回了输入的SearchTerm

197
00:10:20,650 --> 00:10:23,200
并 updateSearch 将模板排入队列

198
00:10:23,200 --> 00:10:24,733
以便它在那里可用。

199
00:10:26,700 --> 00:10:31,700
如果我们现在保存它，它会重新加载，但我看不到任何用户。

200
00:10:32,710 --> 00:10:34,980
不过，这只是我在这里的一个错字。

201
00:10:34,980 --> 00:10:38,330
我应该传入 props.users

202
00:10:38,330 --> 00:10:41,620
因为 users 是我在这里的道具名称。

203
00:10:41,620 --> 00:10:44,280
因此，如果我使用它，那么我正在喂食在用户中，

204
00:10:44,280 --> 00:10:46,100
现在我们在这里看到它们。

205
00:10:46,100 --> 00:10:49,540
现在排序工作，搜索呢？

206
00:10:49,540 --> 00:10:52,290
如您所知，这看起来不错。

207
00:10:52,290 --> 00:10:56,360
在这里，我们可以搜索和排序

208
00:10:56,360 --> 00:11:00,030
并像我们之前一样选择用户，

209
00:11:00,030 --> 00:11:03,890
但现在我们用我们自己的自定义钩子来做这件事

210
00:11:03,890 --> 00:11:05,580
这支持我们。

211
00:11:05,580 --> 00:11:07,680
我们现在有了这个 useSearch 钩子

212
00:11:07,680 --> 00:11:10,823
因此可以摆脱所有注释掉的代码。

213
00:11:11,700 --> 00:11:13,510
现在这条线在这里，

214
00:11:13,510 --> 00:11:17,010
或者这三行替换所有代码

215
00:11:17,010 --> 00:11:18,980
我们以前在那里。

216
00:11:18,980 --> 00:11:22,080
当然我们现在可以在 ProjectsList 中使用相同的

217
00:11:22,080 --> 00:11:24,380
因为那是我们的主要想法。

218
00:11:24,380 --> 00:11:26,893
我们希望有可重用的代码。