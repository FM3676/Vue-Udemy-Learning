1
00:00:00,120 --> 00:00:01,750
现在是混音，

2
00:00:01,750 --> 00:00:04,930
一种非常有用的数据共享机制

3
00:00:04,930 --> 00:00:07,470
和跨组件的功能，

4
00:00:07,470 --> 00:00:10,550
在具有全局混合功能的所有组件中

5
00:00:10,550 --> 00:00:13,220
或跨几个选定的组件

6
00:00:13,220 --> 00:00:16,670
通过手动向组件添加混音。

7
00:00:16,670 --> 00:00:19,080
但是mix ins有一些缺点

8
00:00:19,080 --> 00:00:22,890
或至少一个可能更大的缺点。

9
00:00:22,890 --> 00:00:25,010
如果您构建更大的应用程序，

10
00:00:25,010 --> 00:00:27,160
比这里的演示大得多，

11
00:00:27,160 --> 00:00:29,490
你可能也在一个团队中工作，

12
00:00:29,490 --> 00:00:31,410
混音会让它变得更难

13
00:00:31,410 --> 00:00:33,640
了解您的代码，

14
00:00:33,640 --> 00:00:35,290
你的组件结构，

15
00:00:35,290 --> 00:00:37,600
因为它并不总是显而易见的

16
00:00:37,600 --> 00:00:40,470
一些价值来自哪里。

17
00:00:40,470 --> 00:00:43,130
在我们的警报组合中，我们得到了这些显示警报

18
00:00:43,130 --> 00:00:45,190
并隐藏警报方法。

19
00:00:45,190 --> 00:00:47,880
在我们的删除用户组件中，

20
00:00:47,880 --> 00:00:49,410
我们没有这些方法。

21
00:00:49,410 --> 00:00:51,950
当然是因为他们混在其中。

22
00:00:51,950 --> 00:00:55,690
但是我们从模板内部调用它们。

23
00:00:55,690 --> 00:00:57,390
现在，问题在于

24
00:00:57,390 --> 00:01:00,500
是在这个简单的演示中，

25
00:01:00,500 --> 00:01:02,020
因为我们是唯一的开发商

26
00:01:02,020 --> 00:01:03,420
谁在编写此代码，

27
00:01:03,420 --> 00:01:05,920
很明显这是从哪里来的。

28
00:01:05,920 --> 00:01:07,920
但想想更大的项目

29
00:01:07,920 --> 00:01:11,590
其中一个组件可能不只是使用一个，

30
00:01:11,590 --> 00:01:14,580
但是假设有五六个混音。

31
00:01:14,580 --> 00:01:16,770
你可能也在一个团队中工作

32
00:01:16,770 --> 00:01:20,250
许多开发人员在代码库上工作。

33
00:01:20,250 --> 00:01:22,730
然后它并不总是那么明显

34
00:01:22,730 --> 00:01:24,400
东西从哪里来。

35
00:01:24,400 --> 00:01:27,050
如果显示警报来自警报混合，

36
00:01:27,050 --> 00:01:29,630
或者可能来自错误处理组合，

37
00:01:29,630 --> 00:01:31,400
你也可能有。

38
00:01:31,400 --> 00:01:33,150
这可能是一个问题。

39
00:01:33,150 --> 00:01:35,130
随着混入更大的项目，

40
00:01:35,130 --> 00:01:39,040
更大的代码库可能更难管理。

41
00:01:39,040 --> 00:01:40,670
此外，你必须小心

42
00:01:40,670 --> 00:01:42,320
关于这种合并行为。

43
00:01:42,320 --> 00:01:44,350
如果你有一个场景

44
00:01:44,350 --> 00:01:47,430
默认的合并策略不适合您，

45
00:01:47,430 --> 00:01:49,270
是的，你可以覆盖它们，

46
00:01:49,270 --> 00:01:51,280
但这是很多额外的照顾

47
00:01:51,280 --> 00:01:52,930
你必须确保

48
00:01:52,930 --> 00:01:54,610
混合插件正常工作。

49
00:01:54,610 --> 00:01:56,840
即使他们这样做了，你仍然被留下

50
00:01:56,840 --> 00:01:59,690
没有立即看到的问题

51
00:01:59,690 --> 00:02:02,550
某些方法或某些数据块在哪里

52
00:02:02,550 --> 00:02:04,015
来自。

53
00:02:04,015 --> 00:02:06,510
这对你来说可能不是问题，

54
00:02:06,510 --> 00:02:08,270
特别是在较小的项目中

55
00:02:08,270 --> 00:02:09,870
或者如果你自己工作。

56
00:02:09,870 --> 00:02:11,490
但正如我在更大的项目中所说，

57
00:02:11,490 --> 00:02:12,700
这可能是个问题，

58
00:02:12,700 --> 00:02:16,240
这就是为什么 Vue.js 有一个解决方案，

59
00:02:16,240 --> 00:02:18,300
以及为什么 Vue.js 实际上有

60
00:02:18,300 --> 00:02:20,940
为您提供完整的替代方式

61
00:02:20,940 --> 00:02:22,840
编写您的组件。

62
00:02:22,840 --> 00:02:24,900
而不是设置数据，方法，

63
00:02:24,900 --> 00:02:26,800
计算和手表，

64
00:02:26,800 --> 00:02:28,790
当你在整个课程中学习它时，

65
00:02:28,790 --> 00:02:30,910
Vue 提供了另一种方式，

66
00:02:30,910 --> 00:02:32,490
组合 API，

67
00:02:32,490 --> 00:02:33,690
我已经介绍过

68
00:02:33,690 --> 00:02:36,380
在上一个课程模块中。

69
00:02:36,380 --> 00:02:39,600
你可能还记得在最后一个模块中，

70
00:02:39,600 --> 00:02:42,500
我已经提到了一个可能的缺点

71
00:02:42,500 --> 00:02:44,640
你可能会遇到更大的 Vue 应用程序

72
00:02:44,640 --> 00:02:46,670
使用选项 API 时，

73
00:02:46,670 --> 00:02:48,840
所以用数据构建组件的方式，

74
00:02:48,840 --> 00:02:50,220
方法，计算和观察，

75
00:02:50,220 --> 00:02:52,500
我们在本课程的大部分内容中都使用了它。

76
00:02:52,500 --> 00:02:55,450
这是一个很好的方法，但重用逻辑

77
00:02:55,450 --> 00:02:58,850
可能会很棘手或很麻烦，因为我们使用混音

78
00:02:58,850 --> 00:03:02,420
用于在使用该选项 API 时重用逻辑

79
00:03:02,420 --> 00:03:04,830
由于我刚才提到的原因

80
00:03:04,830 --> 00:03:07,960
这在更大的应用程序中可能会出现问题。

81
00:03:07,960 --> 00:03:10,000
并使用组合 API，

82
00:03:10,000 --> 00:03:12,750
我们有更好的方式重用逻辑

83
00:03:12,750 --> 00:03:14,520
跨组件。

84
00:03:14,520 --> 00:03:17,660
因为虽然我们有混合插件来共享逻辑

85
00:03:17,660 --> 00:03:19,570
在选项 API 中，

86
00:03:19,570 --> 00:03:22,030
我们有自定义组合功能

87
00:03:22,030 --> 00:03:24,400
使用组合 API 时。

88
00:03:24,400 --> 00:03:26,323
那么让我们看看它是如何工作的。