1
00:00:02,390 --> 00:00:04,990
所以在项目列表中我们也可以

2
00:00:05,950 --> 00:00:07,939
在这里注释掉所有这些代码

3
00:00:09,550 --> 00:00:14,460
还有这个与搜索有关的观察者，

4
00:00:14,460 --> 00:00:17,423
并在此处删除此功能。

5
00:00:19,561 --> 00:00:23,997
而是导入，使用钩子搜索，搜索 JS。

6
00:00:28,890 --> 00:00:33,633
现在复制我们在用户列表中使用的代码。

7
00:00:35,110 --> 00:00:37,350
所以我们称之为使用搜索，

8
00:00:37,350 --> 00:00:41,230
但现在我想解析一个不同的值。

9
00:00:41,230 --> 00:00:44,890
这里不是我们想要过滤的 props.users，

10
00:00:44,890 --> 00:00:48,120
但它是 props.user.projects。

11
00:00:48,120 --> 00:00:49,773
所以让我们解析一下，

12
00:00:52,070 --> 00:00:54,610
我们不想过滤全名属性

13
00:00:54,610 --> 00:00:59,610
在每个用户项目上，而不是在 title 属性上。

14
00:01:00,250 --> 00:01:02,160
我们可以在原始代码中看到这一点

15
00:01:02,160 --> 00:01:04,260
所以我们应该输入这个。

16
00:01:04,260 --> 00:01:06,330
这样我们就得到了输入的搜索词

17
00:01:06,330 --> 00:01:10,260
可用项目和更新搜索功能。

18
00:01:10,260 --> 00:01:13,010
我们现在可以在组件的其余部分使用它。

19
00:01:13,010 --> 00:01:16,110
例如，这里我们使用可用的项目

20
00:01:16,110 --> 00:01:18,283
现在应该是可用的项目。

21
00:01:20,300 --> 00:01:22,510
在这里，我们使用输入的搜索词

22
00:01:22,510 --> 00:01:24,290
并设置一个新值。

23
00:01:24,290 --> 00:01:27,520
好吧，既然我们在这里得到了裁判，

24
00:01:27,520 --> 00:01:28,550
那应该工作。

25
00:01:28,550 --> 00:01:30,870
在这里分配一个新值应该可以。

26
00:01:30,870 --> 00:01:33,163
这是一个参考。我们可以从任何地方更新它。

27
00:01:35,410 --> 00:01:38,670
然而，在这里，我现在也想退回可用的物品

28
00:01:38,670 --> 00:01:41,240
或仍然可用的项目

29
00:01:41,240 --> 00:01:44,250
这样我就可以在模板中继续使用该名称。

30
00:01:44,250 --> 00:01:48,060
例如这里，但我想存储可用的项目

31
00:01:48,060 --> 00:01:50,293
在那个可用的项目键中。

32
00:01:51,360 --> 00:01:53,300
所以我不会在这里使用速记，

33
00:01:53,300 --> 00:01:56,130
而是存储可用的项目

34
00:01:56,130 --> 00:01:59,720
在此对象的此可用项目属性中

35
00:01:59,720 --> 00:02:01,823
我们回到我们的模板。

36
00:02:02,820 --> 00:02:06,580
我同意，是的，我还在进口

37
00:02:06,580 --> 00:02:09,340
一堆我们不再使用的东西。

38
00:02:09,340 --> 00:02:12,100
让我们删除这里的所有评论

39
00:02:12,100 --> 00:02:16,273
以便更容易查看和修复。

40
00:02:17,940 --> 00:02:18,873
像这样。

41
00:02:19,930 --> 00:02:21,750
而且我们不再使用 ref 了。

42
00:02:21,750 --> 00:02:23,550
我们这里没有其他裁判。

43
00:02:23,550 --> 00:02:26,730
我们还有另一个计算属性和一个观察者。

44
00:02:26,730 --> 00:02:28,550
所以我们想保留这些进口。

45
00:02:28,550 --> 00:02:31,010
我们仍然使用两个 refs，

46
00:02:31,010 --> 00:02:33,530
但是我们不再使用 ref 函数了。

47
00:02:33,530 --> 00:02:35,223
所以我们可以保存并摆脱它。

48
00:02:36,090 --> 00:02:38,580
如果我现在重新加载，我会得到一个错误。

49
00:02:38,580 --> 00:02:41,483
无法读取 null 的属性项目。

50
00:02:42,600 --> 00:02:45,053
什么可能导致这个问题？

51
00:02:47,210 --> 00:02:49,200
嗯，就是这条线。

52
00:02:49,200 --> 00:02:54,200
我正在解析 props.user.project 以使用搜索。

53
00:02:54,250 --> 00:02:56,490
问题在于

54
00:02:56,490 --> 00:02:59,610
我们最初没有选择用户。

55
00:02:59,610 --> 00:03:04,320
所以最初用户为空，我尝试访问项目

56
00:03:04,320 --> 00:03:06,023
在一个空值上。

57
00:03:06,970 --> 00:03:09,040
这里有什么解决方法？

58
00:03:09,040 --> 00:03:11,780
好吧，一种解决方法可能只是

59
00:03:11,780 --> 00:03:14,853
创建一个新的助手、变量或常量。

60
00:03:16,410 --> 00:03:18,290
以项目为例，

61
00:03:18,290 --> 00:03:22,160
我在哪里检查 prop.user 是否是一个东西。

62
00:03:22,160 --> 00:03:24,990
所以，如果这是真的，如果是的话，

63
00:03:24,990 --> 00:03:29,990
我访问 props.user.projects 并将数据存储在项目中。

64
00:03:30,900 --> 00:03:34,730
否则我在项目中存储一个空数组。

65
00:03:34,730 --> 00:03:37,070
然后在这里我只是在项目中解析，

66
00:03:37,070 --> 00:03:40,310
如果我们没有用户，它现在要么是一个空数组

67
00:03:40,310 --> 00:03:43,063
或者这是这个值。

68
00:03:44,730 --> 00:03:46,180
现在这看起来更好。

69
00:03:47,460 --> 00:03:50,170
但是，现在如果我选择不同的用户，

70
00:03:50,170 --> 00:03:53,570
我们总是找不到项目。

71
00:03:53,570 --> 00:03:56,790
所以看起来我们的代码有问题。

72
00:03:56,790 --> 00:03:59,033
现在可能是什么问题？

73
00:04:01,950 --> 00:04:05,880
那么它仍然与那些用户项目有关。

74
00:04:05,880 --> 00:04:09,923
我对组合 API 模块中的道具说了什么？

75
00:04:11,430 --> 00:04:15,170
我说 props 对象是反应式的，

76
00:04:15,170 --> 00:04:16,839
但是里面的属性，

77
00:04:16,839 --> 00:04:19,880
嵌套在那里的值没有。

78
00:04:19,880 --> 00:04:22,570
现在我在这里做的是执行设置时

79
00:04:22,570 --> 00:04:25,620
第一次，我正在拉动这个项目

80
00:04:25,620 --> 00:04:27,340
或这个空数组。

81
00:04:27,340 --> 00:04:28,230
就是这样。

82
00:04:28,230 --> 00:04:30,210
设置不会再次运行。

83
00:04:30,210 --> 00:04:32,170
如果我们在那之后选择一个用户，

84
00:04:32,170 --> 00:04:34,400
此代码不会再次运行。

85
00:04:34,400 --> 00:04:37,933
所以项目将始终保持这个空数组。

86
00:04:39,090 --> 00:04:41,650
我们需要对用户变化做出反应

87
00:04:41,650 --> 00:04:45,660
并更新项目和一种简单的方法

88
00:04:45,660 --> 00:04:48,743
将是我们在这里使用计算属性。

89
00:04:51,650 --> 00:04:53,340
拿这个代码，

90
00:04:53,340 --> 00:04:56,440
在该计算属性内部的函数中，

91
00:04:56,440 --> 00:04:58,440
我们现在返回了这个代码。

92
00:04:58,440 --> 00:05:01,410
通过这样做，我们确保计算

93
00:05:01,410 --> 00:05:04,350
因此查看注意道具

94
00:05:04,350 --> 00:05:07,090
因为它将 props 检测为依赖项

95
00:05:07,090 --> 00:05:08,890
在那个计算的属性中

96
00:05:08,890 --> 00:05:10,680
每当道具发生变化时，

97
00:05:10,680 --> 00:05:12,320
因此这里的用户发生了变化，

98
00:05:12,320 --> 00:05:16,730
每当发生这种情况时，它都会给我们带来新的项目。

99
00:05:16,730 --> 00:05:19,190
我们实际上可以缩短一点。

100
00:05:19,190 --> 00:05:23,060
我已经让我的用户作为道具的参考

101
00:05:23,060 --> 00:05:24,900
这条线在那里。

102
00:05:24,900 --> 00:05:29,900
如果我们把线保持在下面，实际上把它移到这里，

103
00:05:30,240 --> 00:05:32,910
我们现在可以只引用用户，

104
00:05:32,910 --> 00:05:35,310
这也确保了这个计算的属性

105
00:05:35,310 --> 00:05:38,500
每当道具改变时都不会重新评估，

106
00:05:38,500 --> 00:05:40,800
但仅当用户道具更改时。

107
00:05:40,800 --> 00:05:42,380
哪个更有效率，

108
00:05:42,380 --> 00:05:44,180
虽然在这里没关系

109
00:05:44,180 --> 00:05:46,203
因为我们只需要使用我们的道具。

110
00:05:47,740 --> 00:05:50,070
虽然这也不完全是这样，

111
00:05:50,070 --> 00:05:52,510
请记住用户现在是参考

112
00:05:52,510 --> 00:05:54,690
所以我们必须检查 user.value

113
00:05:54,690 --> 00:05:56,803
这里还有user.value。

114
00:05:57,760 --> 00:06:00,970
然而，它看起来应该可以工作，

115
00:06:00,970 --> 00:06:04,020
但我们将介绍一个微妙的新问题。

116
00:06:04,020 --> 00:06:06,770
现在的项目是一个参考，对吧？

117
00:06:06,770 --> 00:06:08,730
因为它是一个计算属性

118
00:06:08,730 --> 00:06:11,830
和计算的属性是只读的参考。

119
00:06:11,830 --> 00:06:15,493
所以我正在解析一个 ref 以使用搜索。

120
00:06:16,540 --> 00:06:18,400
在用户列表中，我们正在做其他事情。

121
00:06:18,400 --> 00:06:20,790
这里我在 props.users 中解析

122
00:06:20,790 --> 00:06:23,620
如您所知，属性内的值

123
00:06:23,620 --> 00:06:26,910
关闭你的道具对象不是参考。

124
00:06:26,910 --> 00:06:30,410
所以这里 props.users，我传入的数组，

125
00:06:30,410 --> 00:06:31,903
不是参考。

126
00:06:32,940 --> 00:06:37,253
在项目列表中，我解析的是我们的参考。

127
00:06:38,830 --> 00:06:40,700
现在在搜索JS中，

128
00:06:40,700 --> 00:06:44,440
因此，我有时会得到参考的项目

129
00:06:44,440 --> 00:06:48,000
有时项目只是一个数组。

130
00:06:48,000 --> 00:06:52,350
现在我绝对想要这里的 ref 功能

131
00:06:52,350 --> 00:06:54,480
因为这里的计算属性

132
00:06:54,480 --> 00:06:57,923
当我们的项目发生变化时应该重新评估。

133
00:06:59,230 --> 00:07:01,770
但当然， items.filter 将不起作用

134
00:07:01,770 --> 00:07:03,280
如果 items 是参考。

135
00:07:03,280 --> 00:07:06,600
那应该是 items.value 过滤器，

136
00:07:06,600 --> 00:07:08,820
这里应该是 items.value

137
00:07:08,820 --> 00:07:11,040
这里应该是 items.value138
00:07:12,460 --> 00:07:14,520
但现在我们当然会面临问题

139
00:07:14,520 --> 00:07:18,143
当项目不是用户列表中的参考时。

140
00:07:18,990 --> 00:07:22,220
不过，这个问题有一个简单的解决方案。

141
00:07:22,220 --> 00:07:27,140
我们也可以在这里简单地使用两个 refs。

142
00:07:27,140 --> 00:07:28,063
像这样。

143
00:07:30,090 --> 00:07:35,090
并从两个 refs 道具中拉出我们的用户。

144
00:07:35,350 --> 00:07:38,200
所以我在项目列表中使用的方法相同

145
00:07:38,200 --> 00:07:41,530
这样我就可以解析现在是 ref 的用户

146
00:07:41,530 --> 00:07:42,703
使用搜索。

147
00:07:43,680 --> 00:07:47,210
从技术上讲，这里不需要，但是

148
00:07:47,210 --> 00:07:51,230
我们确保 use search 总是收到一个 ref

149
00:07:51,230 --> 00:07:54,663
作为它的项目，因此 for 将始终有效。

150
00:07:57,360 --> 00:07:59,930
现在，你会看到我们可以切换

151
00:07:59,930 --> 00:08:02,910
在不同用户之间查看他们的项目。

152
00:08:02,910 --> 00:08:06,353
在这里搜索似乎也有效。

153
00:08:07,652 --> 00:08:09,530
如果我再次切换到用户，

154
00:08:09,530 --> 00:08:11,363
这看起来也不错。

155
00:08:12,690 --> 00:08:14,120
像这样。

156
00:08:14,120 --> 00:08:17,910
所以现在我们让这个功能再次工作。

157
00:08:17,910 --> 00:08:21,660
然而，现在，我们自己使用搜索钩子

158
00:08:21,660 --> 00:08:24,760
因此使用可重用的代码。

159
00:08:24,760 --> 00:08:27,030
是的，有些事情

160
00:08:27,030 --> 00:08:28,600
我们不得不提防

161
00:08:28,600 --> 00:08:31,870
与这个 ref 反应性有关。

162
00:08:31,870 --> 00:08:34,480
但毕竟，我们能够弄清楚。

163
00:08:34,480 --> 00:08:36,613
现在我们有了灵活的可重用性，

164
00:08:37,460 --> 00:08:39,080
多亏了这个自定义钩子，

165
00:08:39,080 --> 00:08:41,313
我们在两个组件中使用它。