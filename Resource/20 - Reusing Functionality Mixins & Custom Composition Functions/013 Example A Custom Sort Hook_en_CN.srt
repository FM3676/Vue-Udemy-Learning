1
00:00:02,410 --> 00:00:04,150
我们成功了吗？

2
00:00:04,150 --> 00:00:05,350
让我们一起试试这个。

3
00:00:06,410 --> 00:00:07,920
我会为此添加一个新的钩子。

4
00:00:07,920 --> 00:00:08,890
一个新文件。

5
00:00:08,890 --> 00:00:11,130
排序点js

6
00:00:11,130 --> 00:00:13,257
我会导出一个函数，

7
00:00:13,257 --> 00:00:14,540
使用排序。

8
00:00:14,540 --> 00:00:16,219
听起来像一个合适的名字。

9
00:00:16,219 --> 00:00:17,053
到底哪个，

10
00:00:17,053 --> 00:00:18,800
以后应该更换，

11
00:00:18,800 --> 00:00:20,461
这种排序功能。

12
00:00:20,461 --> 00:00:22,670
所以这个排序参考，

13
00:00:22,670 --> 00:00:24,360
这个计算的属性，

14
00:00:24,360 --> 00:00:25,963
和这个功能。

15
00:00:28,110 --> 00:00:31,020
因此，我们可以抓住所有这些，

16
00:00:31,020 --> 00:00:33,620
把它剪在这里，在用户列表中，

17
00:00:33,620 --> 00:00:34,83​​0
实际上把它移过来

18
00:00:34,83​​0 --> 00:00:37,853
进入这个新创建的 useSort 函数。

19
00:00:39,440 --> 00:00:42,320
现在，我在这里使用计算属性和 ref。

20
00:00:42,320 --> 00:00:46,400
所以，我们应该从 vue 导入 ref 和计算。

21
00:00:46,400 --> 00:00:48,383
以便这些功能可用。

22
00:00:49,514 --> 00:00:53,300
我也依赖于availableItems点值，

23
00:00:53,300 --> 00:00:55,480
因此，这应该是一个输入，

24
00:00:55,480 --> 00:00:57,233
此函数中的一个参数。

25
00:00:58,310 --> 00:01:00,920
所以，我会在这里接受 availableItems，

26
00:01:00,920 --> 00:01:02,073
作为参数。

27
00:01:04,190 --> 00:01:08,580
我也依靠 fullName 进行比较，

28
00:01:08,580 --> 00:01:10,520
哪个项目应该先出现。

29
00:01:10,520 --> 00:01:14,070
当然，这对用户来说非常具体。

30
00:01:14,070 --> 00:01:16,770
现在在这里，我们只使用排序功能，

31
00:01:16,770 --> 00:01:17,800
为用户。

32
00:01:17,800 --> 00:01:19,470
所以我们可以这样。

33
00:01:19,470 --> 00:01:23,170
但是如果你想要一个更通用的排序功能，

34
00:01:23,170 --> 00:01:25,830
一个更通用的 useSort 钩子，

35
00:01:25,830 --> 00:01:29,150
我们可能想在这里接受一个动态值。

36
00:01:29,150 --> 00:01:31,590
这样sortProperty，

37
00:01:31,590 --> 00:01:33,630
是我们得到的另一个参数。

38
00:01:33,630 --> 00:01:37,410
然后在这里，我们访问这个动态值。

39
00:01:37,410 --> 00:01:39,460
这样任何属性名称，

40
00:01:39,460 --> 00:01:41,810
可以从外面传入。

41
00:01:41,810 --> 00:01:42,663
像这样。

42
00:01:44,610 --> 00:01:46,970
然而，有了这个，我们应该没问题。

43
00:01:46,970 --> 00:01:48,780
而现在，我们又可以回来了，

44
00:01:48,780 --> 00:01:51,790
我们的数据和功能，

45
00:01:51,790 --> 00:01:52,623
等等，

46
00:01:52,623 --> 00:01:55,210
从 useSort 函数内部，

47
00:01:55,210 --> 00:01:58,113
到我们要称呼它的地方。

48
00:01:58,980 --> 00:02:02,570
所以在这里，我想返回displayedUsers，

49
00:02:02,570 --> 00:02:03,723
并排序，

50
00:02:05,415 --> 00:02:07,850
显示用户和排序，

51
00:02:07,850 --> 00:02:09,770
这样他们就可以回到用户列表，

52
00:02:09,770 --> 00:02:11,830
并在那里使用该数据。

53
00:02:11,830 --> 00:02:13,330
我在用户列表中看到，

54
00:02:13,330 --> 00:02:17,010
我还将对我的模板进行排序。

55
00:02:17,010 --> 00:02:18,580
因此，在 useSort 中，

56
00:02:18,580 --> 00:02:21,360
我们还应该返回这个排序参考。

57
00:02:21,360 --> 00:02:23,960
因此，我们可以在 setup 方法中使用它，

58
00:02:23,960 --> 00:02:25,623
用户列表组件。

59
00:02:27,300 --> 00:02:29,750
然后在 UserList 组件中，

60
00:02:29,750 --> 00:02:31,860
我们可以导入，

61
00:02:31,860 --> 00:02:33,580
使用排序自

62
00:02:34,980 --> 00:02:36,700
挂钩，

63
00:02:36,700 --> 00:02:38,163
排序.js。

64
00:02:39,520 --> 00:02:40,570
现在，

65
00:02:40,570 --> 00:02:42,013
在这里调用 useSort。

66
00:02:44,420 --> 00:02:45,577
并

67
00:02:45,577 --> 00:02:46,680
使用排序，

68
00:02:46,680 --> 00:02:49,170
我想转发我的可用项目。

69
00:02:49,170 --> 00:02:51,080
所以我在这里得到的availableItems，

70
00:02:51,080 --> 00:02:52,460
从使用搜索。

71
00:02:52,460 --> 00:02:54,630
这是一个参考，一个只读参考，

72
00:02:54,630 --> 00:02:55,690
如果你记得。

73
00:02:55,690 --> 00:02:56,830
所以我转发这个

74
00:02:56,830 --> 00:02:58,363
现在使用排序。

75
00:02:59,630 --> 00:03:02,670
而且，我也传入这个属性，

76
00:03:02,670 --> 00:03:03,950
您要对其进行排序。

77
00:03:03,950 --> 00:03:05,633
这里是全名。

78
00:03:07,080 --> 00:03:08,640
我们得到一个对象，

79
00:03:08,640 --> 00:03:10,560
我们可以对其进行解构。

80
00:03:10,560 --> 00:03:14,800
我们将在哪里收到这三个属性。

81
00:03:14,800 --> 00:03:16,760
所以，我在这里复制它们，

82
00:03:16,760 --> 00:03:19,000
把它们放在这里，重新格式化。

83
00:03:19,000 --> 00:03:20,650
现在我们有一个排序常量，

84
00:03:20,650 --> 00:03:22,090
一个显示的用户常量，

85
00:03:22,090 --> 00:03:24,263
和一个 sort const 可用here。

86
00:03:25,250 --> 00:03:27,330
排序将是这个排序功能。

87
00:03:27,330 --> 00:03:30,020
它将指向这个排序函数，

88
00:03:30,020 --> 00:03:32,380
我们在 useSort 中定义的

89
00:03:32,380 --> 00:03:34,300
并返回这里。

90
00:03:34,300 --> 00:03:35,630
并显示用户，

91
00:03:35,630 --> 00:03:38,170
将是显示的用户计算属性。

92
00:03:38,170 --> 00:03:40,430
因此，只读参考。

93
00:03:40,430 --> 00:03:42,480
排序是我们的常规参考，

94
00:03:42,480 --> 00:03:44,260
我们在这里定义的，

95
00:03:44,260 --> 00:03:45,093
在使用排序。

96
00:03:47,010 --> 00:03:49,970
所以现在，我们正在转发排序和排序，

97
00:03:49,970 --> 00:03:53,163
到模板和显示的用户也是如此。

98
00:03:54,530 --> 00:03:56,040
如果我们现在保存这个，

99
00:03:56,040 --> 00:03:56,930
我收到一个错误，

100
00:03:56,930 --> 00:03:58,790
我还在进口一些东西，

101
00:03:58,790 --> 00:04:00,110
我不再需要了，

102
00:04:00,110 --> 00:04:02,300
在 UserList 点 vue 文件中。

103
00:04:02,300 --> 00:04:04,420
因为我们没有定义任何参考，

104
00:04:04,420 --> 00:04:06,670
或计算属性了。

105
00:04:06,670 --> 00:04:08,540
所以，我们可以删除这两个导入

106
00:04:08,540 --> 00:04:10,730
并继续导入 toRefs，

107
00:04:10,730 --> 00:04:12,253
因为我还在用那个。

108
00:04:13,550 --> 00:04:14,393
有了它，

109
00:04:15,630 --> 00:04:16,579
仍然编译，

110
00:04:16,579 --> 00:04:18,550
我可以在这里看到应用程序。

111
00:04:18,550 --> 00:04:20,610
排序似乎有效，

112
00:04:20,610 --> 00:04:22,253
和以前一样。

113
00:04:23,140 --> 00:04:25,510
所以，如果我试一试，

114
00:04:25,510 --> 00:04:26,343
是的，

115
00:04:26,343 --> 00:04:28,160
这似乎有效。

116
00:04:28,160 --> 00:04:29,540
有了这个，

117
00:04:29,540 --> 00:04:31,200
我们现在也会有，

118
00:04:31,200 --> 00:04:33,793
我们可重用的 useSort 钩子。

119
00:04:34,890 --> 00:04:37,140
现在，分解 API 的目标，

120
00:04:37,140 --> 00:04:39,050
不就是你一直，

121
00:04:39,050 --> 00:04:42,070
需要外包所有设置逻辑，

122
00:04:42,070 --> 00:04:44,030
成单独的钩子。

123
00:04:44,030 --> 00:04:45,210
在这里，我们只是在做

124
00:04:45,210 --> 00:04:47,130
这是出于练习目的。

125
00:04:47,130 --> 00:04:48,650
绝对没问题

126
00:04:48,650 --> 00:04:50,220
如果你有一些参考，

127
00:04:50,220 --> 00:04:52,310
和计算属性等等，

128
00:04:52,310 --> 00:04:54,053
留在此设置方法中。

129
00:04:54,980 --> 00:04:56,450
在这里，事实证明，

130
00:04:56,450 --> 00:04:59,291
我们只有这两个主要功能，

131
00:04:59,291 --> 00:05:01,500
现在外包，

132
00:05:01,500 --> 00:05:03,350
现在应该可以使用

133
00:05:03,350 --> 00:05:05,130
在此处的任何组件中，

134
00:05:05,130 --> 00:05:09,270
需要搜索或排序功能。

135
00:05:09,270 --> 00:05:11,280
这就是最大的优势

136
00:05:11,280 --> 00:05:13,375
分解API。

137
00:05:13,375 --> 00:05:17,020
特别是，一旦您了解了自定义钩子。

138
00:05:17,020 --> 00:05:19,520
因为现在我们这里有一个精益组件。

139
00:05:19,520 --> 00:05:21,570
我们得到了可重用的功能。

140
00:05:21,570 --> 00:05:23,060
这真的让我们，

141
00:05:23,060 --> 00:05:25,150
构建超级巨大的组件，

142
00:05:25,150 --> 00:05:27,033
仍然可以维护。