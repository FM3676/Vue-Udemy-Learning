1
00:00:02,320 --> 00:00:04,000
现在作为第一步

2
00:00:04,000 --> 00:00:06,930
在我们上传任何东西之前，

3
00:00:06,930 --> 00:00:10,630
我们想要完成我们的代码，我们想要完善我们的代码

4
00:00:10,630 --> 00:00:13,330
并确保它已优化。

5
00:00:13,330 --> 00:00:16,239
这当然意味着我们要测试它，

6
00:00:16,239 --> 00:00:18,670
我们想测试不同的场景

7
00:00:18,670 --> 00:00:22,730
并在代码中找到可能的错误并修复它们。

8
00:00:22,730 --> 00:00:26,380
我们可能还想考虑重构我们的代码

9
00:00:26,380 --> 00:00:29,330
这样我们就不会经常重复自己，

10
00:00:29,330 --> 00:00:33,290
或者我们用更少的代码解决了某个问题，

11
00:00:33,290 --> 00:00:35,550
因为你拥有的代码越少，

12
00:00:35,550 --> 00:00:38,920
您网站的用户必须下载的代码越少

13
00:00:38,920 --> 00:00:41,020
在他们看到屏幕上的东西之前，

14
00:00:41,020 --> 00:00:44,420
所以更少的代码意味着更快的网站。

15
00:00:44,420 --> 00:00:47,490
还有一种特定的优化技术

16
00:00:47,490 --> 00:00:49,440
我想仔细看看，

17
00:00:49,440 --> 00:00:53,120
那将是异步组件，

18
00:00:53,120 --> 00:00:55,270
Vue 支持。

19
00:00:55,270 --> 00:00:58,660
现在，那是什么，什么是异步组件？

20
00:00:58,660 --> 00:01:00,330
我正在学习这个课程项目，

21
00:01:00,330 --> 00:01:02,650
我们在本课程前面构建的，

22
00:01:02,650 --> 00:01:05,580
你会发现附加的代码快照

23
00:01:05,580 --> 00:01:08,330
以防你手头没有那个。

24
00:01:08,330 --> 00:01:12,050
在这里，我们有一堆组件，几个组件

25
00:01:12,050 --> 00:01:15,220
我们通过 Vue 路由器将其作为页面加载，

26
00:01:15,220 --> 00:01:17,070
和一堆一般的代码。

27
00:01:17,070 --> 00:01:18,890
现在我们绝对可以测试这个

28
00:01:18,890 --> 00:01:21,330
我们绝对可以重构一些代码，

29
00:01:21,330 --> 00:01:23,970
但这不是我想在这里关注的。

30
00:01:23,970 --> 00:01:27,680
而不是想要专注于异步组件方法。

31
00:01:27,680 --> 00:01:29,560
我的意思是什么？

32
00:01:29,560 --> 00:01:31,240
嗯，有某些组件

33
00:01:31,240 --> 00:01:34,863
每次加载此应用程序时我们都不需要。

34
00:01:35,710 --> 00:01:40,580
一个很好的例子就是对话，

35
00:01:40,580 --> 00:01:42,730
我们在登录期间在这里看到。

36
00:01:42,730 --> 00:01:46,610
当我们登录时，我们需要它，但在这个应用程序的其余部分，

37
00:01:46,610 --> 00:01:48,780
我们不经常使用它，

38
00:01:48,780 --> 00:01:52,670
所以我们可能并不总是需要对话组件。

39
00:01:52,670 --> 00:01:54,750
这意味着

40
00:01:54,750 --> 00:01:58,720
我们不一定需要下载源代码

41
00:01:58,720 --> 00:02:01,260
一直在那个组件后面，

42
00:02:01,260 --> 00:02:05,200
因为正如我提到的，如果用户访问这个网页

43
00:02:05,200 --> 00:02:07,490
必须下载更少的代码，

44
00:02:07,490 --> 00:02:10,009
这意味着该网站可以更早地使用，

45
00:02:10,009 --> 00:02:13,530
您不必等待下载尽可能多的代码。

46
00:02:13,530 --> 00:02:15,910
所以对话可能是一个组成部分

47
00:02:15,910 --> 00:02:19,570
我们可以延迟加载，异步加载，

48
00:02:19,570 --> 00:02:22,630
只有当我们需要它而不是提前，

49
00:02:22,630 --> 00:02:25,460
因为现在，所有这些组件，

50
00:02:25,460 --> 00:02:29,190
下载所有页面和所有其他组件

51
00:02:29,190 --> 00:02:33,490
一直以来，无论用户是否需要它们，

52
00:02:33,490 --> 00:02:35,390
这意味着我们拥有一切

53
00:02:35,390 --> 00:02:37,610
在我们需要的时候可用，太好了，

54
00:02:37,610 --> 00:02:41,480
但这也意味着我们要提前下载很多代码，

55
00:02:41,480 --> 00:02:45,470
我们还不需要，或者我们可能永远不需要。

56
00:02:45,470 --> 00:02:48,910
在此处的许多路线中都可以找到类似的示例，

57
00:02:48,910 --> 00:02:53,250
注册为长途汽车路线，例如，对于这个用户，

58
00:02:53,250 --> 00:02:56,670
因为我已经是教练了，我什至不能去参观，

59
00:02:56,670 --> 00:02:58,870
所以我绝对不需要为此编写代码。

60
00:02:59,770 --> 00:03:02,490
这就是 Vue 可以帮助我们的地方，

61
00:03:02,490 --> 00:03:04,800
让我们从基本对话开始，

62
00:03:04,800 --> 00:03:06,473
我们并不总是需要它。

63
00:03:07,760 --> 00:03:11,620
在 main.js 中，我们注册了这个基本对话。

64
00:03:11,620 --> 00:03:14,100
我们从这个文件中导入基础对话

65
00:03:14,100 --> 00:03:15,860
然后我们注册它。

66
00:03:15,860 --> 00:03:18,660
每当您有这样的导入语句时，

67
00:03:18,660 --> 00:03:21,280
这到底告诉了 Vue 代码

68
00:03:21,280 --> 00:03:24,350
在您要导入的那个文件中，

69
00:03:24,350 --> 00:03:28,170
你可以想象所有这些进口到最后，

70
00:03:28,170 --> 00:03:32,460
当你构建你的项目时，当你完成你的项目时，

71
00:03:32,460 --> 00:03:35,000
所有这些导入的文件基本上都合并了

72
00:03:35,000 --> 00:03:38,633
成一个大文件，有点，这就是你可以想象的。

73
00:03:39,640 --> 00:03:42,990
因此，如果我们不导入它会很棒，

74
00:03:42,990 --> 00:03:45,810
如果我们只在需要时导入它，

75
00:03:45,810 --> 00:03:48,850
那么它就不会被合并到这个大文件中，

76
00:03:48,850 --> 00:03:51,150
但是 Vue 会尝试下载

77
00:03:51,150 --> 00:03:54,350
仅在需要时才使用所需的代码。

78
00:03:54,350 --> 00:03:57,060
为此，Vue 有一个我们可以使用的功能，

79
00:03:57,060 --> 00:04:00,173
defineAsyncComponent 函数。

80
00:04:01,480 --> 00:04:04,130
有了它，我们可以定义一个组件

81
00:04:04,130 --> 00:04:07,623
仅在需要时才异步加载。

82
00:04:08,660 --> 00:04:12,660
在这里，我们可以创建一个常量命名的基本对话

83
00:04:12,660 --> 00:04:15,650
这样我就不用在那里改名字了

84
00:04:15,650 --> 00:04:18,149
我存储的值就是结果

85
00:04:18,149 --> 00:04:20,623
调用defineAsyncComponent。

86
00:04:21,538 --> 00:04:25,620
defineAsyncComponent 想要一个函数，

87
00:04:25,620 --> 00:04:27,793
在这里我使用箭头函数。

88
00:04:28,880 --> 00:04:30,760
它想要一个最终的功能

89
00:04:30,760 --> 00:04:33,710
然后返回导入的组件，

90
00:04:33,710 --> 00:04:36,000
但是 Vue 只会调用那个函数

91
00:04:36,000 --> 00:04:38,310
当确实需要该组件时。

92
00:04:38,310 --> 00:04:40,700
所以在这里我可以使用速记符号

93
00:04:40,700 --> 00:04:44,520
箭头函数和调用导入，

94
00:04:44,520 --> 00:04:48,980
它在 JavaScript 中也作为这样的函数存在。

95
00:04:48,980 --> 00:04:51,250
所以这不是我们这里的 import 声明，

96
00:04:51,250 --> 00:04:54,600
相反，现在我将 import 作为函数调用。

97
00:04:54,600 --> 00:04:57,410
当我们将 import 作为函数调用时，

98
00:04:57,410 --> 00:05:00,180
那只会做那个导入

99
00:05:00,180 --> 00:05:02,310
当周围的代码执行时，

100
00:05:02,310 --> 00:05:04,150
在这种情况下，就是这个函数

101
00:05:04,150 --> 00:05:07,330
我们传递给defineAsyncComponent。

102
00:05:07,330 --> 00:05:10,810
嗯，这个函数是由 Vue 执行的

103
00:05:10,810 --> 00:05:14,910
仅在使用该组件时，在需要时。

104
00:05:14,910 --> 00:05:16,740
有了这个，我们确保代码

105
00:05:16,740 --> 00:05:19,030
整个基础对话组件

106
00:05:19,030 --> 00:05:20,633
仅在需要时导入。

107
00:05:21,590 --> 00:05:24,960
现在为此，我们仍然需要提供一条路径

108
00:05:24,960 --> 00:05:28,520
到这里要导入的那个组件，

109
00:05:28,520 --> 00:05:30,740
但现在有了这个动态导入，

110
00:05:30,740 --> 00:05:35,480
我们不会提前导入它，而是仅在需要时导入。

111
00:05:35,480 --> 00:05:37,580
现在我们仍然可以分配基础对话

112
00:05:37,580 --> 00:05:40,640
作为基础对话的组件，

113
00:05:40,640 --> 00:05:43,190
Vue 会知道如何处理

114
00:05:43,190 --> 00:05:45,883
当它需要将对话带到屏幕上时。

115
00:05:47,290 --> 00:05:50,130
所以如果我们保存并重新加载，

116
00:05:50,130 --> 00:05:53,720
如果我像这样注销并登录，

117
00:05:53,720 --> 00:05:56,580
我们仍然看到对话，所以它仍然有效，

118
00:05:56,580 --> 00:05:59,840
但实际上代码只在需要时才下载，

119
00:05:59,840 --> 00:06:02,430
我可以向你证明这一点，再次注销，

120
00:06:02,430 --> 00:06:05,030
然后去那里登录并重新加载，

121
00:06:05,030 --> 00:06:07,030
我们可以打开开发工具，

122
00:06:07,030 --> 00:06:10,940
忽略此处的警告并转到网络。

123
00:06:10,940 --> 00:06:12,490
现在我必须重新加载，

124
00:06:13,860 --> 00:06:15,810
你看到几个文件

125
00:06:15,810 --> 00:06:19,090
从我们的开发服务器下载的，

126
00:06:19,090 --> 00:06:22,870
你在这里看到的一个文件是这个 0.js 文件，

127
00:06:22,870 --> 00:06:24,480
也许它对你的命名不同，

128
00:06:24,480 --> 00:06:27,180
但您应该会看到一个额外的 JavaScript 文件

129
00:06:27,180 --> 00:06:29,900
在 app.js 旁边，这是您的主要应用程序，

130
00:06:29,900 --> 00:06:33,430
也许还有这个 chunk-vendors.js 文件。

131
00:06:33,430 --> 00:06:36,710
现在，如果我登录，你不会在这里看到任何变化，

132
00:06:36,710 --> 00:06:39,520
但如果我现在去注册成为教练，

133
00:06:39,520 --> 00:06:43,760
如果我现在清除此网络日志并重新加载，

134
00:06:43,760 --> 00:06:47,710
您仍然可以看到 0.js，但您只看到过一次。

135
00:06:47,710 --> 00:06:51,075
如果我现在再次清除它并回到所有教练那里

136
00:06:51,075 --> 00:06:53,860
你现在看到这里，就是那里

137
00:06:53,860 --> 00:06:58,580
这个文件实际上是下载的，最后是0.js

138
00:06:58,580 --> 00:07:02,133
保存此对话的转换代码。

139
00:07:03,010 --> 00:07:04,710
如果你在这里看这段代码，很难说，

140
00:07:04,710 --> 00:07:06,620
但这就是你会在那里找到的。

141
00:07:06,620 --> 00:07:09,900
你可以在这里看到一些提示，比如这个名字。

142
00:07:09,900 --> 00:07:11,180
所以我现在想给你看的

143
00:07:11,180 --> 00:07:13,610
是 Vue 现在检查模板吗

144
00:07:13,610 --> 00:07:16,120
您当前正在使用的组件中，

145
00:07:16,120 --> 00:07:19,960
如果这些模板都没有使用对话，

146
00:07:19,960 --> 00:07:22,680
它不下载对话，

147
00:07:22,680 --> 00:07:25,360
和教练注册组件

148
00:07:25,360 --> 00:07:28,700
不使用对话，也不使用教练形式

149
00:07:28,700 --> 00:07:30,890
或那里的任何其他子组件。

150
00:07:30,890 --> 00:07:33,830
这就是为什么在这里，如果你在应用程序的这一部分，

151
00:07:33,830 --> 00:07:37,150
Vue 不会下载对话。

152
00:07:37,150 --> 00:07:39,440
另一方面，对于所有教练页面，

153
00:07:39,440 --> 00:07:43,093
它确实会下载它，因为在教练名单上，

154
00:07:44,015 --> 00:07:46,843
我们确实使用基本对话，

155
00:07:49,810 --> 00:07:52,400
这是一个非常简洁的功能。

156
00:07:52,400 --> 00:07:54,940
现在关于我在这里收到的警告，

157
00:07:54,940 --> 00:07:58,440
这可能只是 Vue 目前的一个错误

158
00:07:58,440 --> 00:08:01,110
因为一切似乎都正常工作，我们

159
00:08:01,110 --> 00:08:04,423
绝对正确使用defineAsyncComponent。

160
00:08:05,440 --> 00:08:08,140
现在我们不能只使用 defineAsyncComponent

161
00:08:08,140 --> 00:08:10,910
但是，对于像这样的全局组件，

162
00:08:10,910 --> 00:08:14,000
我们也可以将它用于本地组件，

163
00:08:14,000 --> 00:08:18,260
而且，这很有趣，对于路线，

164
00:08:18,260 --> 00:08:20,280
因为在这里，我们可能得到了

165
00:08:20,280 --> 00:08:23,360
最大的代码拆分潜力。

166
00:08:23,360 --> 00:08:25,780
如果我们从不访问某条路线，

167
00:08:25,780 --> 00:08:28,700
获取该路由组件的所有代码

168
00:08:28,700 --> 00:08:32,293
并且那里的所有子组件确实是多余的。

169
00:08:33,409 --> 00:08:34,809
因此，在这里，我们也可以

170
00:08:34,809 --> 00:08:39,230
使用这个 defineAsyncComponent 函数，

171
00:08:39,230 --> 00:08:41,696
所以我们可以从 Vue 导入

172
00:08:41,696 --> 00:08:46,696
这个defineAsyncComponent函数在router.js里面。

173
00:08:48,780 --> 00:08:50,900
然后我们可以替换路线

174
00:08:50,900 --> 00:08:54,070
可能从未访问过

175
00:08:54,070 --> 00:08:56,740
带有异步加载的组件。

176
00:08:56,740 --> 00:08:58,777
例如，CoachDetail，

177
00:08:59,730 --> 00:09:02,950
也许用户从不点击该详细信息按钮，

178
00:09:02,950 --> 00:09:04,930
那么我们也可以设置 CoachDetail

179
00:09:04,930 --> 00:09:09,200
等于defineAsyncComponent，向它传递一个函数，

180
00:09:09,200 --> 00:09:13,783
在那里调用导入，然后指向这条路径。

181
00:09:14,770 --> 00:09:17,380
然后我们可以注释掉这个静态导入

182
00:09:17,380 --> 00:09:20,293
在顶部，只使用动态的。

183
00:09:21,690 --> 00:09:24,590
我们可以为教练注册做同样的事情。

184
00:09:26,830 --> 00:09:29,853
在我看来，这应该是 CoachRegistration。

185
00:09:31,000 --> 00:09:35,673
我们也可以在这里抓取这个，调用defineAsyncComponent，

186
00:09:36,750 --> 00:09:41,440
并动态导入，这样如果用户

187
00:09:41,440 --> 00:09:44,170
从不访问教练注册页面，

188
00:09:44,170 --> 00:09:46,810
我们不费心为它加载代码，

189
00:09:46,810 --> 00:09:48,673
所以我们也可以注释掉。

190
00:09:49,620 --> 00:09:51,500
我们可以为所有这些组件做到这一点

191
00:09:51,500 --> 00:09:54,480
或者对于大多数组件，我会说这是有道理的。

192
00:09:54,480 --> 00:09:56,680
例如，对于 ContactCoach，

193
00:09:56,680 --> 00:09:59,760
也许用户从不发送联系信息，

194
00:09:59,760 --> 00:10:01,760
好吧，那我们就不需要加载代码了

195
00:10:01,760 -->00:10:04,510
对于该组件及其子组件，

196
00:10:04,510 --> 00:10:07,020
所以这是另一个组件

197
00:10:07,020 --> 00:10:09,263
我们可以变成一个异步组件。

198
00:10:10,500 --> 00:10:14,440
为什么我们不对 RequestsReceived 做同样的事情呢？

199
00:10:16,060 --> 00:10:19,010
也许这个页面从未被访问过，

200
00:10:19,010 --> 00:10:23,120
所以在这里，我们也可以懒加载，

201
00:10:23,120 --> 00:10:25,733
异步的，而不是一直的，

202
00:10:27,440 --> 00:10:29,853
所以让我们也评论一下。

203
00:10:30,840 --> 00:10:32,290
身份验证也是如此，

204
00:10:32,290 --> 00:10:35,960
如果用户通过身份验证并重新加载页面，

205
00:10:35,960 --> 00:10:38,950
我们不需要再次加载认证页面，

206
00:10:38,950 --> 00:10:41,713
我们不需要它，所以我们可以复制它，

207
00:10:43,420 --> 00:10:48,397
并使用 AsyncComponents 懒惰地加载它，

208
00:10:50,410 --> 00:10:54,390
并将其注释掉。

209
00:10:54,390 --> 00:10:56,920
你可能会发现更多这有意义的地方，

210
00:10:56,920 --> 00:10:59,490
但我会选择这些组件。

211
00:10:59,490 --> 00:11:04,100
而且现在还要更改教练注册名，

212
00:11:04,100 --> 00:11:05,753
我之前打错了。

213
00:11:08,130 --> 00:11:10,510
有了这个，如果你保存这个，

214
00:11:10,510 --> 00:11:13,963
您会注意到，如果您打开网络选项卡，

215
00:11:17,890 --> 00:11:21,260
你看到这里下载了一堆块，

216
00:11:21,260 --> 00:11:23,390
你可以在这里忽略这些块，

217
00:11:23,390 --> 00:11:26,390
你看到只有 0.js 出现了两次，

218
00:11:26,390 --> 00:11:29,510
那就是唯一的额外代码块

219
00:11:29,510 --> 00:11:31,390
这真的是下载的。

220
00:11:31,390 --> 00:11:35,200
所以只有 0.js 出现了两次，但是例如，

221
00:11:35,200 --> 00:11:38,720
如果我点击请求，我们会看到 1.js 已下载，

222
00:11:38,720 --> 00:11:40,257
所以看起来这是代码

223
00:11:40,257 --> 00:11:42,720
对于收到的请求页面。

224
00:11:42,720 --> 00:11:44,770
如果我去注册成为教练，

225
00:11:44,770 --> 00:11:47,380
我们看到另一个代码文件被下载，

226
00:11:47,380 --> 00:11:52,350
所以现在真的只在我们需要的时候下载文件，

227
00:11:52,350 --> 00:11:55,860
这当然非常有用，因为有了它，

228
00:11:55,860 --> 00:12:00,300
我们可以下载一个更苗条的初始捆绑包，然后只

229
00:12:00,300 --> 00:12:03,963
根据需要下载额外的组件代码。

230
00:12:05,240 --> 00:12:08,050
这就是异步组件背后的想法，

231
00:12:08,050 --> 00:12:10,530
因此这是一个关键的优化步骤

232
00:12:10,530 --> 00:12:14,103
您应该注意，尤其是在路由方面。