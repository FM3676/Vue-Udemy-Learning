1
00:00:02,210 --> 00:00:04,810
现在，虽然我们实现了导航守卫，

2
00:00:04,810 --> 00:00:06,980
我已经提出了一个问题。

3
00:00:06,980 --> 00:00:09,760
每当我们手动输入网址时，

4
00:00:09,760 --> 00:00:13,130
我们丢失了所有的身份验证数据。

5
00:00:13,130 --> 00:00:15,320
这当然也意味着如果我们离开这个页面

6
00:00:15,320 --> 00:00:16,810
我们稍后再回来，

7
00:00:16,810 --> 00:00:19,090
即使我们在五分钟前登录，

8
00:00:19,090 --> 00:00:21,060
我们将不得不再次登录。

9
00:00:21,060 --> 00:00:23,780
因为每次重新加载此页面时，

10
00:00:23,780 --> 00:00:28,480
我们用一个新的 Vue X 商店启动一个新的 Vue 应用程序

11
00:00:28,480 --> 00:00:30,040
因此我们拥有的所有数据

12
00:00:30,040 --> 00:00:32,850
之前在 Vue X 商店中丢失了。

13
00:00:32,850 --> 00:00:36,120
这就是浏览器和 JavaScript 的工作方式。

14
00:00:36,120 --> 00:00:40,130
但这并不意味着我们不能存储数据，

15
00:00:40,130 --> 00:00:42,810
在浏览器重新加载后幸存下来。

16
00:00:42,810 --> 00:00:44,820
因此，这是我接下来要做的事情。

17
00:00:44,820 --> 00:00:48,720
我想确保用户可以保持登录状态。

18
00:00:48,720 --> 00:00:50,410
为此，我们首先，

19
00:00:50,410 --> 00:00:53,480
需要进行我们的身份验证操作

20
00:00:53,480 --> 00:00:56,300
并在这里稍微重构了一个代码。

21
00:00:56,300 --> 00:00:59,270
我们已经登录和注册操作

22
00:00:59,270 --> 00:01:01,050
和注销操作。

23
00:01:01,050 --> 00:01:05,300
我将添加一个新的操作身份验证，它获取一个上下文，

24
00:01:05,300 --> 00:01:09,060
现在我将重构其他两个动作

25
00:01:10,051 --> 00:01:12,840
这样我们就没有太多的代码重复

26
00:01:12,840 --> 00:01:15,180
因为我现在将添加更多代码

27
00:01:15,180 --> 00:01:17,213
否则它将被复制。

28
00:01:18,100 --> 00:01:22,150
所以我将从登录中包装这段代码并复制它

29
00:01:22,150 --> 00:01:26,043
并将其添加到新的身份验证操作中，

30
00:01:27,600 --> 00:01:28,930
摆脱控制台日志，

31
00:01:28,930 --> 00:01:30,393
我们不再需要那个了。

32
00:01:32,610 --> 00:01:35,260
在这里，我现在只期望在有效载荷上，

33
00:01:35,260 --> 00:01:40,260
我在这里，我还获得了模式登录或注册。

34
00:01:40,520 --> 00:01:42,823
所以可能是有效载荷上的模式键。

35
00:01:43,870 --> 00:01:46,820
然后我们得到了 URL，它是一个变量，

36
00:01:46,820 --> 00:01:51,453
默认情况下，假设是这里的登录 URL。

37
00:01:53,770 --> 00:01:56,720
但是如果模式等于注册，

38
00:01:56,720 --> 00:02:00,730
然后我想替换 URL

39
00:02:00,730 --> 00:02:02,660
使用注册网址，

40
00:02:02,660 --> 00:02:05,333
我们可以从注册操作中获取。

41
00:02:06,460 --> 00:02:09,023
复制它并在此处添加。

42
00:02:11,100 --> 00:02:15,740
这里的想法是我们现在可以在这里简单地使用 URL

43
00:02:15,740 --> 00:02:17,610
在实际的 fetch 函数中

44
00:02:17,610 --> 00:02:20,320
并在之前适当地重置 URL

45
00:02:21,580 --> 00:02:24,100
其余的代码无论如何都是一样的。

46
00:02:24,100 --> 00:02:26,863
所以在这里我们真的不需要区分。

47
00:02:28,560 --> 00:02:31,540
现在，我也想在这里使用异步

48
00:02:31,540 --> 00:02:34,530
所以这仍然返回一个承诺

49
00:02:34,530 --> 00:02:36,510
我们可以使用 await 关键字，

50
00:02:36,510 --> 00:02:38,293
所以 auth 应该是异步的。

51
00:02:40,490 --> 00:02:43,000
现在我们可以进入登录操作

52
00:02:43,970 --> 00:02:47,140
并摆脱所有这些代码

53
00:02:47,140 --> 00:02:49,460
而是使用上下文调度

54
00:02:49,460 --> 00:02:52,090
发送身份验证操作

55
00:02:52,090 --> 00:02:54,580
这里从登录操作内部

56
00:02:54,580 --> 00:02:56,290
并传递一个对象

57
00:02:57,300 --> 00:02:58,540
我首先，

58
00:02:58,540 --> 00:03:01,970
使用 Spread 运算符复制现有的有效负载，

59
00:03:01,970 --> 00:03:06,110
因此传播从有效载荷复制所有键值对

60
00:03:06,110 --> 00:03:08,040
进入这个新对象，

61
00:03:08,040 --> 00:03:11,000
它已作为有效负载传递给 auth 操作。

62
00:03:11,000 --> 00:03:13,680
然后我添加模式并将其设置为在此处登录

63
00:03:13,680 --> 00:03:16,433
因为我们需要在身份验证操作中使用该模式键。

64
00:03:17,550 --> 00:03:20,813
然后我们可以复制它并为注册做同样的事情

65
00:03:22,930 --> 00:03:24,873
并在此处设置注册模式。

66
00:03:27,380 --> 00:03:31,980
现在很重要，我们要返回调度结果

67
00:03:31,980 --> 00:03:35,100
所以这个由auth返回的promise，

68
00:03:35,100 --> 00:03:37,860
结束不都是l返回的登录并注册

69
00:03:37,860 --> 00:03:41,910
这样我们的组件仍然可以跟踪

70
00:03:41,910 --> 00:03:44,660
我们是否还在等待回复，

71
00:03:44,660 --> 00:03:47,760
我们是否有错误等等。

72
00:03:47,760 --> 00:03:51,280
随着这种变化，如果我去登录，

73
00:03:51,280 --> 00:03:53,013
让我们快速测试一下。

74
00:03:54,290 --> 00:03:55,950
这看起来还是不错的。

75
00:03:55,950 --> 00:04:00,950
所以看起来我们仍然能够发送这些请求。

76
00:04:02,290 --> 00:04:04,510
是的，这看起来不错。

77
00:04:04,510 --> 00:04:07,463
使用已存在的用户注册失败。

78
00:04:08,380 --> 00:04:10,110
所以现在我重构了这个

79
00:04:10,110 --> 00:04:12,200
我这样做是有充分理由的

80
00:04:12,200 --> 00:04:15,360
因为现在我们必须存储这些数据，

81
00:04:15,360 --> 00:04:19,600
令牌，本地 ID，现在，或者至少很快，

82
00:04:19,600 --> 00:04:23,430
不仅在 UX 中过期，

83
00:04:23,430 --> 00:04:25,840
我们确实需要它，但不仅仅是，

84
00:04:25,840 --> 00:04:30,840
而且在页面重新加载后仍然存在的一些存储中。

85
00:04:31,750 --> 00:04:34,960
一个很好的例子就是本地存储，

86
00:04:34,960 --> 00:04:38,100
这是一个内置在浏览器中的 API。

87
00:04:38,100 --> 00:04:39,780
所以这是一些浏览器存储，

88
00:04:39,780 --> 00:04:42,293
我们可以从 JavaScript 内部访问它。

89
00:04:43,600 --> 00:04:46,253
为此，在我提交用户集之前，

90
00:04:47,710 --> 00:04:51,300
我将像这样访问本地存储，

91
00:04:51,300 --> 00:04:53,600
它在浏览器中可用，

92
00:04:53,600 --> 00:04:56,970
然后调用 set item 存储在新数据中

93
00:04:56,970 --> 00:04:58,253
在本地存储中。

94
00:04:59,800 --> 00:05:02,593
最后，我想存储我的令牌，

95
00:05:03,520 --> 00:05:07,853
我从响应 data.id 令牌中获得。

96
00:05:09,520 --> 00:05:13,030
我还想存储用户ID，

97
00:05:13,030 --> 00:05:16,500
我从响应数据中获得，本地 ID。

98
00:05:16,500 --> 00:05:18,870
所以现在我们不只是将它提交给用户体验，

99
00:05:18,870 --> 00:05:22,130
但我们也将其存储在浏览器存储中。

100
00:05:22,130 --> 00:05:25,950
我这样做是为了让我们也可以添加一个动作

101
00:05:25,950 --> 00:05:29,260
应用启动时我们在哪里检查这些数据

102
00:05:29,260 --> 00:05:31,240
当数据可用时，

103
00:05:31,240 --> 00:05:34,330
我们自动登录用户。

104
00:05:34,330 --> 00:05:36,490
因为此刻，如果我保存它，

105
00:05:36,490 --> 00:05:38,270
如果我们重新加载这个应用程序，

106
00:05:38,270 --> 00:05:40,130
如果我登录，

107
00:05:40,130 --> 00:05:42,410
它仍然像以前一样工作。

108
00:05:42,410 --> 00:05:45,300
当我重新加载时，状态就会丢失。

109
00:05:45,300 --> 00:05:48,370
但是现在如果你去浏览器的 Def 工具

110
00:05:48,370 --> 00:05:51,800
至少在您的 Chrome 应用程序中，

111
00:05:51,800 --> 00:05:53,550
你可以访问本地存储，

112
00:05:53,550 --> 00:05:54,990
你可以看到，

113
00:05:54,990 --> 00:05:58,770
在这里你会看到一个用户 ID 和一个令牌字段，

114
00:05:58,770 --> 00:06:00,920
这就是我刚刚存储的数据。

115
00:06:02,090 --> 00:06:05,520
现在我们可以使用它来登录用户。

116
00:06:05,520 --> 00:06:08,630
顺便说一句，我们可以查看这些数据，但它也是我们的数据。

117
00:06:08,630 --> 00:06:10,110
所以这没问题。

118
00:06:10,110 --> 00:06:11,913
它属于我们作为用户。

119
00:06:13,380 --> 00:06:15,570
所以现在我们可以添加一个新的动作

120
00:06:16,610 --> 00:06:21,610
自动登录或尝试登录任何你想命名的，

121
00:06:22,060 --> 00:06:23,720
我们就是这样做的。

122
00:06:23,720 --> 00:06:25,910
我们检查该数据是否存在

123
00:06:25,910 --> 00:06:28,933
如果是，我们设置一个用户，如果不是，我们不设置。

124
00:06:29,980 --> 00:06:32,690
所以在这里我们也得到了上下文。

125
00:06:32,690 --> 00:06:35,650
然后我们就可以访问本地存储了

126
00:06:35,650 --> 00:06:38,353
并得到一个物品，令牌，

127
00:06:39,230 --> 00:06:41,630
存储在令牌常量中，

128
00:06:41,630 --> 00:06:43,733
还获取用户 ID，

129
00:06:46,470 --> 00:06:51,470
然后检查我们是否有一个令牌和一个用户 ID，比方说，

130
00:06:51,670 --> 00:06:55,313
然后我想上下文提交，

131
00:06:56,540 --> 00:07:00,900
设置用户并传递该数据。

132
00:07:00,900 --> 00:07:03,700
所以在这里通过有效载荷来设置用户，

133
00:07:03,700 --> 00:07:06,570
我将令牌设置为我们提取的令牌

134
00:07:06,570 --> 00:07:09,370
从本地存储并设置用户 ID

135
00:07:09,370 --> 00:07:12,310
到我们从本地存储中提取的用户 ID

136
00:07:13,240 --> 00:07:16,900
并将令牌过期时间设置为 null137
00:07:16,900 --> 00:07:18,670
因为我们还没有使用它。

138
00:07:18,670 --> 00:07:19,973
这很快就会改变。

139
00:07:21,260 --> 00:07:25,000
如果我们没有令牌或没有用户 ID，

140
00:07:25,000 --> 00:07:29,470
这不会被提交，我们也不会设置用户。

141
00:07:29,470 --> 00:07:32,563
可以这么说，我们不会自动登录用户。

142
00:07:33,690 --> 00:07:37,390
然而，有了这个，我们现在需要调度这个动作

143
00:07:37,390 --> 00:07:40,150
每当我们的应用开始检查时

144
00:07:40,150 --> 00:07:42,773
我们是否可以自动登录用户。

145
00:07:43,810 --> 00:07:47,260
最好的地方是 App Vue 文件

146
00:07:47,260 --> 00:07:49,420
因为那是我们的根组件。

147
00:07:49,420 --> 00:07:52,933
这是在整个应用程序启动时首先创建的。

148
00:07:54,200 --> 00:07:59,080
所以在这里我们可以添加创建的生命周期钩子，

149
00:07:59,080 --> 00:08:01,850
创建此组件时已触发。

150
00:08:01,850 --> 00:08:04,800
然后我们可以在那里联系我们的商店

151
00:08:04,800 --> 00:08:08,943
并发送尝试登录操作。

152
00:08:10,950 --> 00:08:13,430
有了这个，如果我们保存这个，

153
00:08:13,430 --> 00:08:15,940
你看看我现在是否重新加载，

154
00:08:15,940 --> 00:08:18,393
我实际上最终进入了登录模式。

155
00:08:20,720 --> 00:08:24,840
我什至可以根据请求重新加载，然后我们就留在那个页面上。

156
00:08:24,840 --> 00:08:28,323
所以现在自动登录用户。

157
00:08:29,160 --> 00:08:31,560
我们现在唯一需要处理的事情

158
00:08:31,560 --> 00:08:34,409
是我们注销后清除了数据，

159
00:08:34,409 --> 00:08:37,610
因为此时如果我重新加载，我会再次登录，

160
00:08:37,610 --> 00:08:40,580
因为我没有清除本地存储中的数据。

161
00:08:40,580 --> 00:08:44,220
我们还应该自动注销用户

162
00:08:44,220 --> 00:08:45,950
当令牌过期时，

163
00:08:45,950 --> 00:08:49,360
因为事实证明令牌的生命周期是有限的

164
00:08:49,360 --> 00:08:50,853
出于安全原因。