1
00:00:02,220 --> 00:00:05,110
所以让我们从注销用户开始

2
00:00:05,110 --> 00:00:06,490
并清除数据。

3
00:00:06,490 --> 00:00:11,000
为此以及除提交此操作之外的注销操作，

4
00:00:11,000 --> 00:00:13,740
我们还应该使用本地存储

5
00:00:13,740 --> 00:00:18,740
并删除令牌和所有删除用户 ID。

6
00:00:20,380 --> 00:00:22,250
现在这是容易的部分。

7
00:00:22,250 --> 00:00:26,130
更棘手的部分是我们想要注销用户

8
00:00:26,130 --> 00:00:28,483
如果令牌过期自动。

9
00:00:29,350 --> 00:00:31,580
为此，令牌到期，

10
00:00:31,580 --> 00:00:34,863
不过，我们目前并没有真正使用它。

11
00:00:35,810 --> 00:00:37,440
现在当我们登录时

12
00:00:39,350 --> 00:00:41,970
这里像这样，

13
00:00:41,970 --> 00:00:45,410
在我们从 Firebase 返回的数据中，

14
00:00:45,410 --> 00:00:49,130
正如您在他们的文档中看到的那样，我们也得到了字段过期，

15
00:00:49,130​​ --> 00:00:52,690
这是一个文本，但实际上包含秒数

16
00:00:52,690 --> 00:00:55,350
ID 令牌在其中过期。

17
00:00:55,350 --> 00:00:59,280
我可以告诉你默认情况下，那将是 3,600 秒，

18
00:00:59,280 --> 00:01:00,483
这是一个小时。

19
00:01:01,380 --> 00:01:04,200
现在我们要存储到期日期，

20
00:01:04,200 --> 00:01:07,090
不是持续时间，因为那对我们没有帮助，

21
00:01:07,090 --> 00:01:08,610
但保质期

22
00:01:08,610 --> 00:01:11,560
将来当令牌失效时，

23
00:01:11,560 --> 00:01:14,720
每当我们登录用户时。

24
00:01:14,720 --> 00:01:19,720
所以在我们的关闭操作中，我们发送请求的地方，

25
00:01:20,520 --> 00:01:23,270
当我们将数据存储在本地存储中时，

26
00:01:23,270 --> 00:01:28,270
我们现在还想推导出到期日期，

27
00:01:28,440 --> 00:01:31,690
其中有一个未来的日期，即当前日期，

28
00:01:31,690 --> 00:01:35,363
加上令牌过期前的秒数。

29
00:01:36,610 --> 00:01:40,280
因此，我们可以通过调用新日期来获取当前日期

30
00:01:40,280 --> 00:01:42,700
这给了我们当前的时间戳。

31
00:01:42,700 --> 00:01:47,490
但现在我想在这里添加一些东西，实际上是为了那个

32
00:01:47,490 --> 00:01:49,300
我会打电话给时间

33
00:01:49,300 --> 00:01:53,321
以毫秒为单位获取当前时间戳

34
00:01:53,321 --> 00:01:55,930
我想添加到期时间，

35
00:01:55,930 --> 00:01:58,710
以毫秒为单位的过期持续时间。

36
00:01:58,710 --> 00:02:00,970
因此，为此我将添加过期时间

37
00:02:02,790 --> 00:02:07,790
并从 responseData.expiresIn 乘以 1,000 得到

38
00:02:10,335 --> 00:02:12,680
并确保将其转换为数字

39
00:02:12,680 --> 00:02:14,770
通过在此处添加一个加号。

40
00:02:14,770 --> 00:02:17,010
这就是将字符串转换为数字

41
00:02:17,010 --> 00:02:20,980
然后因为这是以秒为单位，所以我乘以 1,000

42
00:02:20,980 --> 00:02:22,810
以毫秒为单位

43
00:02:22,810 --> 00:02:27,610
然后我可以在这里添加过期日期，

44
00:02:27,610 --> 00:02:32,330
以毫秒为单位有一个新的过期时间戳，

45
00:02:32,330 --> 00:02:33,850
这将在未来。

46
00:02:33,850 --> 00:02:36,293
当前时间加上该持续时间。

47
00:02:37,860 --> 00:02:39,670
还有这个保质期，

48
00:02:39,670 --> 00:02:43,460
现在也必须存储在本地存储中。

49
00:02:43,460 --> 00:02:48,460
所以这里我设置了一个新的项目，就是过期时间，

50
00:02:49,040 --> 00:02:51,350
这称为令牌到期，

51
00:02:51,350 --> 00:02:54,543
这就是到期日。

52
00:02:58,200 --> 00:03:03,200
在这里，我们现在还在 UX 中存储数据的到期日期。

53
00:03:04,920 --> 00:03:07,800
实际上，我们甚至在 UX 中都不需要它

54
00:03:07,800 --> 00:03:09,820
因为本地存储就足够了。

55
00:03:09,820 --> 00:03:12,970
只有当我们重新加载页面时，它才对我们很重要。

56
00:03:12,970 --> 00:03:16,330
所以我们不需要在这里然后在突变中提交它，

57
00:03:16,330 --> 00:03:18,290
我们实际上也可以在这里摆脱它

58
00:03:21,900 --> 00:03:26,253
在尝试登录时，我们也不需要再设置它了。

59
00:03:27,400 --> 00:03:30,430
相反，现在我们将其存储在本地存储中，

60
00:03:30,430 --> 00:03:33,530
但我想做另一件关键的事情。

61
00:03:33,530 --> 00:03:37,230
我想在用户登录时设置一个计时器

62
00:03:37,230 --> 00:03:39,550
以便我们自动注销用户

63
00:03:39,550 --> 00:03:42,020
如果该计时器到期。

64
00:03:42,020 --> 00:03:43,810
这也是我们在这里要做的事情

65
00:03:43,810 --> 00:03:45,453
在身份验证操作中。

66
00:03:46,300 --> 00:03:51,300
我将在这里设置一个新的过期时间输入

67
00:03:51,980 --> 00:03:55,470
所以这次以毫秒为持续时间，

68
00:03:55,470 --> 00:03:59,690
在这段时间之后，这个函数将执行。

69
00:03:59,690 --> 00:04:01,253
而在这个函数中，

70
00:04:02,450 --> 00:04:05,620
我将简单地发送注销操作，

71
00:04:05,620 --> 00:04:09,363
因为如果令牌过期，这就是我想做的。

72
00:04:10,730 --> 00:04:15,070
我还想确保我只有一个计时器处于活动状态

73
00:04:15,070 --> 00:04:20,070
一次，所以我实际上会在这里添加一个全局变量，

74
00:04:20,370 --> 00:04:25,370
计时器，我用它来保持这样的计时器，

75
00:04:28,850 --> 00:04:30,700
然后我们可以使用这个计时器变量

76
00:04:30,700 --> 00:04:33,760
从此文件中的任何位置清除计时器。

77
00:04:33,760 --> 00:04:36,000
我想在我们注销时清除它。

78
00:04:36,000 --> 00:04:39,230
当我们注销时，我想调用 clear timeout

79
00:04:39,230 --> 00:04:41,440
并将这个计时器变量传递给它，

80
00:04:41,440 --> 00:04:43,770
清除正在进行的计时器。

81
00:04:43,770 --> 00:04:47,230
例如，如果我们手动点击注销按钮，

82
00:04:47,230 --> 00:04:50,223
然后我也想清除注销计时器。

83
00:04:51,220 --> 00:04:56,220
我当然也想删除令牌过期项

84
00:04:57,610 --> 00:05:00,503
如果我们注销，则从本地存储。

85
00:05:03,150 --> 00:05:05,470
也不再承诺这一点

86
00:05:05,470 --> 00:05:09,083
因为我们不再在 Vuex 中存储令牌过期时间。

87
00:05:10,810 --> 00:05:15,033
所以现在我们在这里登录时设置了这个计时器，

88
00:05:16,930 --> 00:05:20,920
我们还需要在自动登录的时候设置这个定时器，

89
00:05:20,920 --> 00:05:25,030
然后我们需要检查剩余的过期时间

90
00:05:25,030 --> 00:05:28,260
并设置一个新的计时器到那个时间。

91
00:05:28,260 --> 00:05:31,700
这就是我将令牌过期存储在本地存储中的原因。

92
00:05:31,700 --> 00:05:34,260
所以在这里我可以让我的令牌过期

93
00:05:34,260 --> 00:05:39,260
通过访问本地存储获取项目令牌到期，

94
00:05:40,750 --> 00:05:44,060
现在这将是未来的时间戳。

95
00:05:44,060 --> 00:05:45,810
所以我们现在需要找到不同之处

96
00:05:45,810 --> 00:05:48,583
在那个时间戳和当前时间之间，

97
00:05:50,420 --> 00:05:54,083
我将再次将其存储在一个名为 expiresIn 的常量中

98
00:05:55,330 --> 00:05:59,630
这是令牌过期转换为数字

99
00:05:59,630 --> 00:06:04,630
通过在当前时间上加减号

100
00:06:04,750 --> 00:06:07,740
作为以毫秒为单位的时间戳。

101
00:06:07,740 --> 00:06:10,340
所以这将以毫秒为单位

102
00:06:10,340 --> 00:06:13,250
在这个时间和令牌到期的未来之间

103
00:06:13,250 --> 00:06:14,403
和当前时间。

104
00:06:16,250 --> 00:06:20,840
当然，如果过期，这里应该是负数，

105
00:06:20,840 --> 00:06:23,180
那么我们甚至不需要登录用户。

106
00:06:23,180 --> 00:06:27,630
我们甚至可以争辩说，如果它比我们说的要小

107
00:06:27,630 --> 00:06:30,940
10,000 小于 10 秒，

108
00:06:30,940 --> 00:06:34,640
即使这样登录用户也没有任何意义。

109
00:06:34,640 --> 00:06:37,280
但我会在这里使用较小的零。

110
00:06:37,280 --> 00:06:39,790
如果到期时间小于那个值，

111
00:06:39,790 --> 00:06:42,960
那么令牌肯定是无效的

112
00:06:42,960 --> 00:06:46,600
所以在那种情况下，我会回到这里

113
00:06:46,600 --> 00:06:50,150
并且不继续登录用户

114
00:06:50,150 --> 00:06:52,110
因为计时器到了，

115
00:06:52,110 --> 00:06:54,948
没有必要在这里继续。

116
00:06:54,948 --> 00:06:58,280
否则，如果计时器是正数，

117
00:06:58,280 --> 00:07:02,360
如果我们还有足够的时间，如果令牌仍然有效，

118
00:07:02,360 --> 00:07:07,360
我将再次在这里设置一个计时器，以 expiresIn 作为持续时间

119
00:07:07,950 --> 00:07:10,890
就像我在这个函数中的普通计时器一样，

120
00:07:10,890 --> 00:07:15,490
我将调用上下文调度注销

121
00:07:15,490 --> 00:07:18,143
并将该计时器存储在计时器变量中。

122
00:07:21,270 --> 00:07:25,010
好的，理论上应该可以。

123
00:07:25,010 --> 00:07:27,070
为了测试它，

124
00:07:27,070 --> 00:07:30,750
我将手动调整这个过期时间

125
00:07:30,750 --> 00:07:32,160
当我们登录时，

126
00:07:32,160 --> 00:07:37,160
我不会将其设置为实际探索持续时间

127
00:07:37,710 --> 00:07:38,690
我们有。

128
00:07:38,690 --> 00:07:40,190
但相反，我会复制这个

129
00:07:40,190 --> 00:07:41,940
并注释掉正确的

130
00:07:41,940 --> 00:07:45,190
只需将其设置为五秒恩兹。

131
00:07:45,190 --> 00:07:47,883
所以现在五秒钟后，我们应该退出。

132
00:07:49,860 --> 00:07:53,773
因此，如果我们尝试一下并重新加载并在此处登录，

133
00:07:57,080 --> 00:07:59,780
这有效，但五秒钟后

134
00:07:59,780 --> 00:08:02,370
我们不应该再登录了。

135
00:08:02,370 --> 00:08:03,530
这看起来不错。

136
00:08:03,530 --> 00:08:06,433
UI 切换到未登录状态。

137
00:08:07,330 --> 00:08:10,663
如果我在两者之间重新加载页面，那也应该有效。

138
00:08:11,910 --> 00:08:14,250
所以如果我重新加载，我仍然登录，

139
00:08:14,250 --> 00:08:18,173
但这仍然应该更新并且确实如此。

140
00:08:19,140 --> 00:08:22,170
现在我们遇到了这个解决方案的一个问题

141
00:08:22,170 --> 00:08:27,170
如果我访问像请求这样的受保护页面，可以看到，

142
00:08:27,820 --> 00:08:31,870
如果我退出了，我现在会留在这个页面上。

143
00:08:31,870 --> 00:08:34,630
所以我们应该确保我们重定向用户

144
00:08:34,630 --> 00:08:37,683
如果我们自动注销用户。

145
00:08:38,600 --> 00:08:42,860
并在自动注销时实现此重定向，

146
00:08:42,860 --> 00:08:47,357
我将添加一个新操作，我将其命名为 autoLogout

147
00:08:49,820 --> 00:08:52,100
我在哪里得到我的上下文

148
00:08:52,100 --> 00:08:56,253
以及我将在哪里发送常规注销，

149
00:08:57,220 --> 00:09:00,110
但除此之外，

150
00:09:00,110 --> 00:09:04,980
我也将承诺，永远不会突变，

151
00:09:04,980 --> 00:09:08,497
我们还没有添加，我将其命名为 didLogout。

152
00:09:10,610 --> 00:09:15,610
在这个突变确实注销了，我会设置一个新的状态

153
00:09:19,250 --> 00:09:22,573
确实注销了真实，

154
00:09:23,410 --> 00:09:26,930
这是我们首先要添加到我们的一些状态

155
00:09:26,930 --> 00:09:30,890
auth index JS fall 中的主要状态

156
00:09:30,890 --> 00:09:33,113
最初登出是假的，

157
00:09:34,370 --> 00:09:38,010
也许命名它确实自动注销更清楚，

158
00:09:38,010 --> 00:09:41,620
我还会将它命名为在我更新时自动注销

159
00:09:41,620 --> 00:09:46,033
并命名了一个突变，并自动注销。

160
00:09:46,890 --> 00:09:49,850
也许它设置自动注销的名称也是一致的

161
00:09:49,850 --> 00:09:53,580
与另一个突变，然后在动作调度

162
00:09:53,580 --> 00:09:54,913
设置自动注销。

163
00:09:55,760 --> 00:09:58,710
现在我对自动注销的想法是什么，

164
00:09:58,710 --> 00:09:59,713
我现在设置的是哪个？

165
00:10:00,608 --> 00:10:01,441
那应该设置

166
00:10:01,441 --> 00:10:04,460
发送自动注销操作时。

167
00:10:04,460 --> 00:10:08,710
所以现在在计时器里，我想把所有的日志都发送出去

168
00:10:08,710 --> 00:10:12,163
在这里以及我创建计时器的其他地方。

169
00:10:13,320 --> 00:10:18,320
想法是现在在 App View 中，我们可以添加一个观察者

170
00:10:18,490 --> 00:10:22,210
并注意这一切的注销。

171
00:10:22,210 --> 00:10:24,380
为此，我们只需要添加一个 getter

172
00:10:25,620 --> 00:10:29,560
是否自动注销，我们得到了我们的状态

173
00:10:29,560 --> 00:10:32,463
在哪里返回 state.didAutoLogout。

174
00:10:35,870 --> 00:10:38,550
所以我在这个突变中设置的那个状态

175
00:10:38,550 --> 00:10:41,490
由这个 getter 返回并在 App View 中，

176
00:10:41,490 --> 00:10:46,490
然后我们可以添加一个计算属性，自动注销

177
00:10:47,970 --> 00:10:52,970
我在哪里返回了这个 store.getters.didAutoLogout，

178
00:10:55,930 --> 00:11:00,830
然后我们可以看这个，didAutoLogout 计算属性

179
00:11:00,830 --> 00:11:05,830
收到一个新值或当前值和旧值。

180
00:11:06,120 --> 00:11:10,320
我们现在可以检查当前值是否为真。

181
00:11:10,320 --> 00:11:11,820
所以如果我们确实自动注销

182
00:11:11,820 --> 00:11:15,610
当前值与先前值不同。

183
00:11:15,610 --> 00:11:18,530
所以它确实改变了，现在它是真的，

184
00:11:18,530 --> 00:11:20,690
然后我们可以使用路由器

185
00:11:20,690 --> 00:11:23,563
假设重定向到斜线教练。

186
00:11:24,690 --> 00:11:27,550
这样，当我们自动注销用户时，

187
00:11:27,550 --> 00:11:29,520
我们重定向到教练。

188
00:11:29,520 --> 00:11:34,520
所以如果我们现在试一试并且我们正在处理斜线请求，

189
00:11:37,870 --> 00:11:40,170
我们被重定向到教练。

190
00:11:40,170 --> 00:11:41,060
所以现在有了这个，

191
00:11:41,060 --> 00:11:43,590
那将是我能想到的一种方式

192
00:11:43,590 --> 00:11:46,083
应该可以帮助我们将用户重定向到这里。

193
00:11:47,210 --> 00:11:51,270
现在使用自动注销方法和这种突变

194
00:11:51,270 --> 00:11:53,670
我改变的地方确实自动注销，

195
00:11:53,670 --> 00:11:56,970
我也旺如果我们再次登录，请确保我已更改。

196
00:11:56,970 --> 00:11:58,760
所以如果我们再次设置一个用户，

197
00:11:58,760 --> 00:12:02,360
然后自动注销再次设置为false

198
00:12:02,360 --> 00:12:05,320
这样下次它切换到 true 时，

199
00:12:05,320 --> 00:12:07,683
我们也再次作为观察者触发。

200
00:12:08,580 --> 00:12:11,670
如果它是真的并且改变了，这个观察者就会运行

201
00:12:11,670 --> 00:12:14,240
因此我们需要把它改回来。

202
00:12:14,240 --> 00:12:17,170
否则它永远不会再改变。

203
00:12:17,170 --> 00:12:19,730
我也注意到了，当然现在在这里

204
00:12:19,730 --> 00:12:22,620
在模块的 index.js 中，

205
00:12:22,620 --> 00:12:24,950
我们可以在这里摆脱令牌过期

206
00:12:24,950 --> 00:12:28,650
因为我们并没有真正在 Vuex 状态下使用它，

207
00:12:28,650 --> 00:12:30,870
但这只是一个旁注。

208
00:12:30,870 --> 00:12:33,790
有了它，我们添加了自动注销功能

209
00:12:33,790 --> 00:12:35,910
因此在身份验证操作中，

210
00:12:35,910 --> 00:12:40,910
我想把及时过期的切换回实时，

211
00:12:41,320 --> 00:12:44,480
这当然超过五秒。

212
00:12:44,480 --> 00:12:46,363
所以现在如果我们登录，

213
00:12:48,520 --> 00:12:50,870
我们实际上应该保持登录状态

214
00:12:50,870 --> 00:12:53,640
我们可以与这个应用程序进行交互。

215
00:12:53,640 --> 00:12:56,640
例如，发送一条消息

216
00:12:59,560 --> 00:13:04,393
给号码或教练，或者也给自己发信息，

217
00:13:08,890 --> 00:13:13,890
您好，我们现在也可以在请求下看到。

218
00:13:15,530 --> 00:13:17,640
这就是现在所有的自动登录

219
00:13:19,180 --> 00:13:21,230
这样我们就可以重新加载并保持登录状态

220
00:13:21,230 --> 00:13:25,900
并自动注销添加到此应用程序。

221
00:13:25,900 --> 00:13:29,160
因此，我们现在添加了所有关键构建块

222
00:13:29,160 --> 00:13:32,593
您需要将身份验证添加到 View App。